<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Splash Practice</title>

  <style>
    :root{
      --bg:#0b1220;
      --table1:#12204a;
      --table2:#0c1430;
      --panel:rgba(255,255,255,.04);
      --panelBorder:rgba(255,255,255,.10);
      --accent:#63b3ed;
      --danger:#ff7b72;
      --ok:#7ee787;
      --muted:rgba(230,237,247,.72);
      --shadow:0 10px 26px rgba(0,0,0,.45);

      --card-w:76px;
      --card-h:110px;
      --avatar:44px;
      --pile-h:150px;
      --gap:10px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      color:#e6edf7;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(circle at top, #142046, var(--bg) 60%);
      -webkit-tap-highlight-color: transparent;
    }

    header{
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    header h1{
      margin:0;
      font-size:15px;
      font-weight:900;
      letter-spacing:.2px;
    }

    select,button,input{
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.16);
      color:#e6edf7;
      padding:8px 12px;
      border-radius:12px;
      font-size:13px;
      outline:none;
    }

    button{ cursor:pointer; }
    button.primary{ background:rgba(99,179,237,.22); border-color:rgba(99,179,237,.45); }
    button.danger{ background:rgba(255,123,114,.18); border-color:rgba(255,123,114,.45); }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    main{
      max-width:1300px;
      margin:auto;
      padding:12px 12px calc(16px + env(safe-area-inset-bottom));
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 420px;
      gap:12px;
    }

    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .muted{ color:var(--muted); font-size:12px; }
    .small{ font-size:12px; }
    .pill{
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      font-size:12px;
      display:inline-flex;
      gap:6px;
      align-items:center;
      white-space:nowrap;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px;
      padding:2px 6px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
    }

    .table{
      background: linear-gradient(180deg, var(--table1), var(--table2));
      border-radius:20px;
      padding:12px;
      box-shadow: var(--shadow);
    }

    /* Desktop/tablet: seat map */
    .playersRow{
      position:relative;
      height:180px;
      margin-bottom:10px;
    }

    .playerChip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:14px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      min-width:150px;
      position:absolute;
    }

    .playerChip.active{
      outline:2px solid var(--accent);
      box-shadow:0 0 16px rgba(99,179,237,.45);
    }

    .seat-bottom{ left:50%; bottom:0; transform:translateX(-50%); }
    .seat-top{ left:50%; top:0; transform:translateX(-50%); }
    .seat-left{ left:0; top:50%; transform:translateY(-50%); }
    .seat-right{ right:0; top:50%; transform:translateY(-50%); }
    .seat-tl{ left:0; top:0; transform:none; }
    .seat-tr{ right:0; top:0; transform:none; }

    .avatar{
      width:var(--avatar);
      height:var(--avatar);
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      color:#0b1220;
      position:relative;
    }

    .avatar .emo{ font-size:20px; }
    .avatar .init{
      position:absolute;
      bottom:-2px; right:-2px;
      font-size:10px;
      padding:1px 5px;
      border-radius:999px;
      background:#000;
      color:#fff;
    }

    /* Mobile: fall back to the old row layout to avoid overlap */
    @media (max-width: 700px){
      .playersRow{
        position:static;
        height:auto;
        display:flex;
        justify-content:space-between;
        gap:8px;
        flex-wrap:wrap;
        margin-bottom:10px;
      }
      .playerChip{
        position:static;
        transform:none !important;
      }
    }

    .c{
      width:var(--card-w);
      height:var(--card-h);
      border-radius:12px;
      background:#fff;
      color:#111;
      position:relative;
      box-shadow:0 6px 18px rgba(0,0,0,.45);
      transition:.12s ease;
    }

    .c.selectable:hover{ transform:translateY(-4px); }
    .c.selected{ outline:3px solid var(--accent); transform:translateY(-6px); }

    .corner{
      position:absolute;
      font-weight:900;
      font-size:13px;
      line-height:1;
    }
    .corner.top{ top:6px; left:6px; }
    .corner.bottom{ bottom:6px; right:6px; transform:rotate(180deg); }

    .pip{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      font-size:32px;
    }

    .subpip{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      font-size:12px;
      opacity:.75;
      margin-top:30px;
      letter-spacing:.6px;
      font-weight:800;
    }

    .c.back{
      background:linear-gradient(135deg,#1b2a55,#0b1220);
      border:2px dashed rgba(255,255,255,.45);
    }
    .c.illegal{ opacity:.55; }

    .zoneTitle{
      margin:10px 0 6px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
    }

    .hand{ display:flex; gap:var(--gap); flex-wrap:wrap; }
    .handScroll{
      display:flex;
      gap:var(--gap);
      overflow-x:auto;
      padding-bottom:4px;
    }

    .note{
      margin-top:10px;
      padding:10px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .pileRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    .pileVisualWrap{
      width:100%;
      height:var(--pile-h);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
      margin-top:8px;
      position:relative;
      overflow:hidden;
    }

    .pileCard{
      position:absolute;
      left: calc(50% - 38px);
      top: 20px;
      will-change: transform, opacity;
    }

    @keyframes popIn {
      0%{ transform: translateY(18px) scale(.92); opacity:0; }
      100%{ transform: translateY(0) scale(1); opacity:1; }
    }
    .anim-pop{ animation: popIn .18s ease-out; }

    @keyframes pileShake {
      0%{ transform: translateX(0); }
      20%{ transform: translateX(-6px); }
      40%{ transform: translateX(6px); }
      60%{ transform: translateX(-4px); }
      80%{ transform: translateX(4px); }
      100%{ transform: translateX(0); }
    }
    .shake{ animation: pileShake .22s ease-in-out; }

    @keyframes clearBurst {
      0%{ box-shadow: 0 0 0 rgba(99,179,237,0); }
      30%{ box-shadow: 0 0 30px rgba(99,179,237,.55); }
      100%{ box-shadow: 0 0 0 rgba(99,179,237,0); }
    }
    .burst{ animation: clearBurst .35s ease-out; }

    .flyLayer{
      position: fixed;
      inset: 0;
      pointer-events:none;
      z-index: 9999;
    }
    .flyCard{
      position: fixed;
      width: 56px;
      height: 78px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.18);
      background: #fff;
      box-shadow: 0 14px 30px rgba(0,0,0,.55);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      opacity: 0.95;
      transform: translate(0,0) scale(1);
      transition: transform .45s ease, opacity .45s ease;
      color:#111;
    }

    .panel{
      background:rgba(255,255,255,.04);
      border-radius:18px;
      padding:12px;
    }

    .log{
      background:rgba(0,0,0,.35);
      border-radius:14px;
      padding:8px;
      font-family:ui-monospace,monospace;
      font-size:12px;
      max-height:300px;
      overflow:auto;
    }

    .log .line{ padding:2px 0; border-bottom:1px dashed rgba(255,255,255,.07); }
    .log .line:last-child{ border-bottom:none; }

    .ok{ color:var(--ok); }
    .warn{ color:#f2cc60; }
    .bad{ color:var(--danger); }

    @media (max-width: 900px){
      :root{
        --card-w:68px;
        --card-h:100px;
        --avatar:40px;
        --pile-h:130px;
        --gap:8px;
      }
      .grid{ grid-template-columns:1fr; }
    }

    @media (max-width: 480px){
      :root{
        --card-w:60px;
        --card-h:88px;
        --avatar:36px;
        --pile-h:110px;
        --gap:6px;
      }
      header h1{ font-size:14px; }
      select,button{ font-size:12px; padding:7px 10px; }
      .log{ max-height:200px; font-size:11px; }
      .corner{ font-size:11px; }
      .pip{ font-size:26px; }
    }

    .bottomBar{ display:none; }
    @media(max-width:700px){
      .bottomBar{
        display:flex;
        position:fixed;
        left:0; right:0; bottom:0;
        padding:10px 12px calc(10px + env(safe-area-inset-bottom));
        gap:10px;
        background: rgba(8,12,22,.88);
        border-top:1px solid rgba(255,255,255,.10);
        backdrop-filter: blur(10px);
        z-index: 1000;
      }
      .bottomBar button{
        flex:1;
        font-size:15px;
        padding:14px 14px;
        border-radius:16px;
      }
      main{ padding-bottom: 96px; }
      .topActions{ display:none !important; }
    }

    .overlay{
      position:fixed;
      inset:0;
      background: rgba(5,8,14,.86);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 2000;
      padding: 18px;
    }
    .overlay.show{ display:flex; }

    .overlayCard{
      width:min(520px, 100%);
      border-radius:24px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      box-shadow: 0 22px 60px rgba(0,0,0,.6);
      padding:18px;
      text-align:center;
    }
    .overlayCard h2{
      margin:0 0 8px;
      font-size:18px;
      font-weight:900;
    }
    .overlayCard .sub{ color:var(--muted); font-size:13px; margin-bottom:14px; }
    .overlayCard .bigAvatar{
      width:84px; height:84px;
      border-radius:50%;
      margin: 0 auto 14px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:34px;
      font-weight:900;
      color:#0b1220;
      position:relative;
      overflow:hidden;
    }
    .overlayCard .bigAvatar .init{
      position:absolute;
      bottom:4px; right:6px;
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      background: rgba(0,0,0,.75);
      color:#fff;
      border:1px solid rgba(255,255,255,.18);
      letter-spacing:.2px;
    }
    .overlayActions{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .overlayActions button{
      min-width: 160px;
      padding: 12px 16px;
      font-size: 14px;
      border-radius: 16px;
    }

    /* ===== UX additions you already had ===== */
    .c.selectable.legal{
      box-shadow:
        0 0 0 2px rgba(99,179,237,.35),
        0 10px 22px rgba(99,179,237,.25);
    }
    .c.illegal{
      opacity:0.45;
      filter: grayscale(1) blur(.3px);
      cursor:not-allowed;
    }
    @keyframes illegalShake {
      0%{ transform:translateX(0); }
      25%{ transform:translateX(-6px); }
      50%{ transform:translateX(6px); }
      75%{ transform:translateX(-4px); }
      100%{ transform:translateX(0); }
    }
    .c.illegal.shake{
      animation: illegalShake .25s ease-in-out;
    }
    @keyframes seatPulse {
      0%   { box-shadow: 0 0 0 0 rgba(99,179,237,.55); }
      70%  { box-shadow: 0 0 0 14px rgba(99,179,237,0); }
      100% { box-shadow: 0 0 0 0 rgba(99,179,237,0); }
    }
    .playerChip.active{
      animation: seatPulse 1.6s ease-out infinite;
    }
    .playerChip.inactive{
      opacity: 0.55;
      filter: grayscale(.35);
    }
    .turnArrow{
      position:absolute;
      font-size:22px;
      opacity:.85;
      animation: arrowPulse 1.2s ease-in-out infinite;
    }
    @keyframes arrowPulse{
      0%,100%{ transform:translateY(0); opacity:.85; }
      50%{ transform:translateY(6px); opacity:.55; }
    }

    /* ===== Multiplayer header additions ===== */
    .mpbar{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
      margin-left:auto;
    }
    .mpbar input{
      width:90px;
    }
    .mpbar #mpRoom{
      text-transform:uppercase;
      width:90px;
    }
    .mpStatus{
      font-size:12px;
      opacity:.7;
      margin-left:6px;
    }
  </style>
</head>

<body>
<header>
  <h1>üÉè Splash Practice</h1>

  <!-- ‚úÖ Multiplayer controls added (does not replace existing UI) -->
  <div class="mpbar">
    <input id="mpName" placeholder="Name" />
    <input id="mpRoom" placeholder="ROOM" />
    <button id="hostBtn" class="primary">Host</button>
    <button id="joinBtn" class="primary">Join</button>
    <span id="mpStatus" class="mpStatus"></span>
  </div>

  <div class="controls">
    <label class="muted">Players</label>
    <select id="numPlayers">
      <option>3</option><option selected>4</option><option>5</option><option>6</option>
    </select>
    <button id="newGame" class="primary">New Game</button>
    <button id="newHand">New Hand</button>
    <span class="pill" id="handInfo">Hand 1 / 5</span>
    <span class="pill" id="turnInfo">Turn: ‚Äî</span>
  </div>
</header>

<div class="flyLayer" id="flyLayer"></div>

<div class="bottomBar">
  <button id="playBtnMobile" class="primary">Play</button>
  <button id="pickupBtnMobile" class="danger">Pick Up</button>
  <button id="hintBtnMobile">Hint</button>
</div>

<div class="overlay" id="passOverlay" role="dialog" aria-modal="true">
  <div class="overlayCard">
    <div class="bigAvatar" id="passAvatar"><span id="passEmoji">üôÇ</span><span class="init" id="passInit">P1</span></div>
    <h2 id="passTitle">Pass to Player</h2>
    <div class="sub" id="passSub">Only the current player‚Äôs cards will be visible.</div>
    <div class="overlayActions">
      <button id="readyBtn" class="primary">I‚Äôm ready</button>
      <button id="peekBtn">Show table only</button>
    </div>
  </div>
</div>

<main>
  <div class="grid">

    <section class="table">
      <div class="playersRow" id="playersRow"></div>
      <div id="turnArrow" class="turnArrow" style="display:none;">‚¨áÔ∏è</div>

      <div class="note">
        <div class="pileRow">
          <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
            <span class="pill">Draw: <span id="drawCount">‚Äî</span></span>
            <span class="pill" id="discardPill">Discard: <span id="discardCount">‚Äî</span></span>
            <span class="pill">Pile: <span id="pileCount">‚Äî</span></span>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <span class="muted">Top:</span>
            <span class="pill" id="topValue">‚Äî</span>
          </div>
        </div>

        <div class="pileVisualWrap" id="pileVisualWrap"></div>

        <div class="muted" style="margin-top:10px;">
          Face cards (J/Q/K) can only be played on face cards. 10/Joker clears. Triple clears.
        </div>
      </div>

      <div class="zoneTitle">
        <span id="handLabel">Current player hand</span>
        <span class="muted">tap to select ¬∑ double-tap to quick-play</span>
      </div>
      <div id="yourHand" class="handScroll"></div>

      <div class="zoneTitle">
        <span id="tableLabel">Current player table</span>
        <span class="muted">hand + face-up can mix ¬∑ face-down alone</span>
      </div>
      <div id="yourTable" class="hand"></div>
    </section>

    <section class="panel">
      <div class="topActions" style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <button id="playBtn" class="primary">Play Selected</button>
        <button id="pickupBtn" class="danger">Pick Up Pile</button>
        <button id="hintBtn">Hint</button>
      </div>

      <div class="zoneTitle" style="margin-top:12px;">
        <span>Game Log</span>
        <span class="muted">newest first</span>
      </div>
      <div id="log" class="log"></div>
    </section>

  </div>
</main>

<script>
(() => {

  /* =========================================================
     ‚úÖ ONLINE MULTIPLAYER (host broadcasts state, joiners sync)
     ========================================================= */
  const WS_BASE = "wss://splash-multiplayer.azimaymen.workers.dev";
  let mpWs = null;
  let mpRoom = null;
  let mpIsHost = false;
  const mpClientId = crypto.randomUUID();

  function mpSetStatus(t){
    const s = document.getElementById("mpStatus");
    if (s) s.textContent = t;
  }

  function mpConnect(room){
    mpRoom = room.toUpperCase();
    mpWs = new WebSocket(`${WS_BASE}?room=${mpRoom}`);

    mpWs.onopen = () => {
      mpSetStatus(`Connected ${mpRoom}${mpIsHost ? " (host)" : ""}`);
      mpWs.send(JSON.stringify({
        type: "join",
        id: mpClientId,
        name: document.getElementById("mpName").value || "Player"
      }));
    };

    mpWs.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }
      if (msg.type === "state") {
        // joiners apply host state
        if (!mpIsHost) {
          applyRemoteState(msg.payload);
        }
      }
    };

    mpWs.onclose = () => mpSetStatus("Disconnected");
    mpWs.onerror = () => mpSetStatus("Error");
  }

  function mpBroadcast(payload){
    if (!mpWs || mpWs.readyState !== WebSocket.OPEN) return;
    if (!mpIsHost) return;
    mpWs.send(JSON.stringify({ type:"broadcast", payload }));
  }

  function serializeGameState(){
    return JSON.parse(JSON.stringify(state));
  }

  function applyRemoteState(remote){
    // replace the entire state tree
    for (const k of Object.keys(state)) delete state[k];
    Object.assign(state, remote);
    render();
  }

  document.getElementById("hostBtn").onclick = () => {
    mpIsHost = true;
    const code = Math.random().toString(36).slice(2,8).toUpperCase();
    document.getElementById("mpRoom").value = code;
    mpConnect(code);
    alert("Room code: " + code);
  };

  document.getElementById("joinBtn").onclick = () => {
    mpIsHost = false;
    const code = document.getElementById("mpRoom").value.trim();
    if (!code) return alert("Enter room code");
    mpConnect(code);
  };

  /* =========================================================
     YOUR ORIGINAL GAME CODE (unchanged below)
     ========================================================= */

  const SUITS = ["‚ô†","‚ô•","‚ô¶","‚ô£"];
  const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const RANK_ORDER = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const rankOrder = (rank) => RANK_ORDER.indexOf(rank);

  const EMOJIS = ["ü¶ä","üêº","üêØ","ü¶Å","üê∏","üêô","ü¶â","ü¶Ñ","üê≤","üê∂","üê±","üêµ"];

  const SEAT_COLORS = [
    ["#63b3ed","#7ee787"],
    ["#f2cc60","#ff7b72"],
    ["#a78bfa","#63b3ed"],
    ["#34d399","#f2cc60"],
    ["#fb7185","#a78bfa"],
    ["#60a5fa","#fb7185"],
  ];

  const SEAT_CLASSES = ["seat-bottom","seat-left","seat-top","seat-right","seat-tl","seat-tr"];

  const isJoker = c => c.rank === "JOKER";
  const isTenOrJoker = c => c.rank === "10" || isJoker(c);

  const PlayerType = { HUMAN:"HUMAN", BOT:"BOT", REMOTE:"REMOTE" };

  const scoreValue = (card) => {
    if (isJoker(card)) return 50;
    if (card.rank === "10") return 20;
    if (card.rank === "A") return 1;
    if (card.rank === "J" || card.rank === "Q" || card.rank === "K") return 10;
    return parseInt(card.rank, 10);
  };

  const state = {
    numPlayers: 4,
    players: [],
    deck: [],
    discard: [],
    pile: [],
    pileTopRank: null,
    handIndex: 1,
    handsTotal: 5,
    currentPlayer: 0,
    mustPlayAny: false,
    gameOver: false,

    viewPlayer: null,
    revealedThisTurn: false,
    peekOnly: false
  };

  const el = (id) => document.getElementById(id);
  const logEl = el("log");
  const yourHandEl = el("yourHand");
  const yourTableEl = el("yourTable");
  const playersRowEl = el("playersRow");
  const pileVisualWrap = el("pileVisualWrap");
  const flyLayer = el("flyLayer");
  const discardPill = el("discardPill");

  const passOverlay = el("passOverlay");
  const passTitle = el("passTitle");
  const passSub = el("passSub");
  const passAvatar = el("passAvatar");
  const passEmoji = el("passEmoji");
  const passInit = el("passInit");
  const readyBtn = el("readyBtn");
  const peekBtn = el("peekBtn");

  let selected = new Set();
  let selectedSources = new Map();
  let uid = 0;
  const newId = () => (++uid).toString();

  let lastTap = { id: null, t: 0 };

  function toneDot(tone){
    if (tone==="ok") return `<span class="ok">‚óè</span> `;
    if (tone==="warn") return `<span class="warn">‚óè</span> `;
    if (tone==="bad") return `<span class="bad">‚óè</span> `;
    return "";
  }
  function addLog(text, tone=""){
    const div = document.createElement("div");
    div.className = "line";
    div.innerHTML = `${toneDot(tone)}${text}`;
    logEl.prepend(div);
  }

  function flashBurst(){
    pileVisualWrap.classList.remove("burst");
    void pileVisualWrap.offsetWidth;
    pileVisualWrap.classList.add("burst");
  }
  function shakePile(){
    pileVisualWrap.classList.remove("shake");
    void pileVisualWrap.offsetWidth;
    pileVisualWrap.classList.add("shake");
  }
  function flyCardsToDiscard(count){
    const fromRect = pileVisualWrap.getBoundingClientRect();
    const toRect = discardPill.getBoundingClientRect();
    const startX = fromRect.left + fromRect.width * 0.50;
    const startY = fromRect.top + fromRect.height * 0.45;
    const endX = toRect.left + toRect.width * 0.55;
    const endY = toRect.top + toRect.height * 0.50;

    const n = Math.min(10, Math.max(3, Math.ceil(count / 6)));
    for (let i=0;i<n;i++){
      const fc = document.createElement("div");
      fc.className = "flyCard";
      fc.textContent = "üÇ†";
      fc.style.left = (startX + (Math.random()*18-9)) + "px";
      fc.style.top  = (startY + (Math.random()*18-9)) + "px";
      flyLayer.appendChild(fc);

      requestAnimationFrame(() => {
        const dx = (endX - startX) + (Math.random()*14-7);
        const dy = (endY - startY) + (Math.random()*14-7);
        const rot = (Math.random()*40 - 20);
        fc.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg) scale(.75)`;
        fc.style.opacity = "0.0";
      });

      setTimeout(()=>fc.remove(), 520);
    }
  }

  function initialsFromName(name){
    const parts = name.trim().split(/\s+/).filter(Boolean);
    if (parts.length === 0) return "P";
    if (parts.length === 1) return parts[0].slice(0,2).toUpperCase();
    return (parts[0][0] + parts[parts.length-1][0]).toUpperCase();
  }

  function seatGradient(i){
    const [a,b] = SEAT_COLORS[i % SEAT_COLORS.length];
    return `linear-gradient(135deg, ${a}, ${b})`;
  }

  function createPlayers(n){
    return Array.from({length:n}, (_,i)=>({
      id:i,
      type: PlayerType.HUMAN,
      name: `Player ${i+1}`,
      emoji: EMOJIS[i % EMOJIS.length],
      initials: `P${i+1}`,
      hand: [],
      tableUp: Array.from({length:4}, ()=>null),
      tableDown: Array.from({length:4}, ()=>null),
      score: 0
    }));
  }

  function resetSelection(){
    selected.clear();
    selectedSources.clear();
  }

  function topRank(){
    const top = state.pile[state.pile.length-1];
    return top ? top.rank : state.pileTopRank;
  }

  function canPlayOnTop(rank){
    if (state.mustPlayAny) return true;
    const top = topRank();
    if (!top) return true;

    if (rank === "10" || rank === "JOKER") return true;
    if (top === "10" || top === "JOKER") return false;

    const isFace = r => r === "J" || r === "Q" || r === "K";
    if (isFace(rank) && !isFace(top)) return false;

    return rankOrder(rank) <= rankOrder(top);
  }

  function countRankOnPile(rank){
    return state.pile.reduce((acc,c)=> acc + (c.rank === rank ? 1 : 0), 0);
  }

  function checkTripleClear(){
    if (state.pile.length < 3) return false;
    const last = state.pile[state.pile.length-1];
    const r = last.rank;
    if (r === "JOKER") return false;
    return countRankOnPile(r) >= 3;
  }

  function clearPile(reason){
    const n = state.pile.length;
    if (n === 0) return;

    flashBurst();
    flyCardsToDiscard(n);

    state.discard.push(...state.pile);
    state.pile = [];
    state.mustPlayAny = true;

    addLog(`Pile cleared (${reason}). ${n} cards to discard. Play again (ANY).`, "ok");

    // host broadcast
    mpBroadcast(serializeGameState());
  }

  function renderCardText(c){
    if (isJoker(c)) return "JOKER";
    return `${c.rank}${c.suit}`;
  }

  function makeDeck(){
    const deck = [];
    for (let d=0; d<2; d++){
      for (const s of SUITS){
        for (const r of RANKS){
          deck.push({ id:newId(), rank:r, suit:s });
        }
      }
    }
    for (let j=0; j<4; j++){
      deck.push({ id:newId(), rank:"JOKER", suit:"‚òÖ" });
    }
    for (let i=deck.length-1;i>0;i--){
      const k = Math.floor(Math.random()*(i+1));
      [deck[i], deck[k]] = [deck[k], deck[i]];
    }
    return deck;
  }

  function drawStartCard(){
    const c = state.deck.pop();
    state.pile.push(c);
    state.pileTopRank = c.rank;

    if (c.rank === "10" || c.rank === "JOKER") {
      clearPile(`start ${renderCardText(c)}`);
    } else {
      state.mustPlayAny = false;
      addLog(`Start card flipped: ${renderCardText(c)}.`, "warn");
    }
  }

  function beginTurnRevealFlow(){
    state.viewPlayer = null;
    state.revealedThisTurn = false;
    state.peekOnly = false;

    const p = state.players[state.currentPlayer];
    passTitle.textContent = `Pass to ${p.name}`;
    passSub.textContent = `Only ${p.name}‚Äôs cards will be visible.`;
    passEmoji.textContent = p.emoji;
    passInit.textContent = p.initials;
    passAvatar.style.background = seatGradient(p.id);

    passOverlay.classList.add("show");
    render();
  }

  function endOverlayReveal(peekOnly){
    state.viewPlayer = state.currentPlayer;
    state.revealedThisTurn = true;
    state.peekOnly = !!peekOnly;
    passOverlay.classList.remove("show");
    render();
  }

  function dealHand(){
    resetSelection();
    state.deck = makeDeck();
    state.discard = [];
    state.pile = [];
    state.mustPlayAny = false;
    state.gameOver = false;

    for (const p of state.players){
      p.hand = [];
      p.tableUp = Array.from({length:4}, ()=>null);
      p.tableDown = Array.from({length:4}, ()=>null);
    }

    for (let i=0;i<4;i++){
      for (const p of state.players){
        p.tableDown[i] = state.deck.pop();
      }
    }
    for (let i=0;i<4;i++){
      for (const p of state.players){
        p.tableUp[i] = state.deck.pop();
      }
    }
    for (let i=0;i<11;i++){
      for (const p of state.players){
        p.hand.push(state.deck.pop());
      }
    }

    drawStartCard();
    state.currentPlayer = 0;

    addLog(`New hand dealt. ${state.players[state.currentPlayer].name} starts.`, "ok");
    beginTurnRevealFlow();

    mpBroadcast(serializeGameState());
  }

  function rankSortKey(r){
    if (r === "JOKER") return 99;
    return Math.max(0, RANK_ORDER.indexOf(r)) + 1;
  }

  function makeRealCardDiv(card, opts){
    const div = document.createElement("div");
    const selectable = !!opts.selectable;
    const selectedOn = !!opts.selectedOn;
    const back = !!opts.back;

    div.className = "c" + (selectable ? " selectable" : "") + (selectedOn ? " selected" : "");
    if (back){
      div.classList.add("back");
      div.innerHTML = `<div class="pip" style="color:rgba(255,255,255,.9)">üÇ†</div>`;
      return div;
    }

    if (isJoker(card)){
      div.innerHTML = `<div class="corner top">JOKER<br>‚òÖ</div><div class="pip">‚òÖ</div><div class="corner bottom">JOKER<br>‚òÖ</div>`;
      return div;
    }

    div.innerHTML = `
      <div class="corner top">${card.rank}<br>${card.suit}</div>
      <div class="pip">${card.suit}</div>
      <div class="corner bottom">${card.rank}<br>${card.suit}</div>
    `;
    return div;
  }

  function renderSelectableCard(card, src){
    const selectedOn = selected.has(card.id);
    const div = makeRealCardDiv(card, { selectable:true, selectedOn, back:false });

    const legal = canPlayOnTop(card.rank);

    if (legal){
      div.classList.add("legal");
    } else if (!state.mustPlayAny){
      div.classList.add("illegal");
    }

    div.onclick = () => {
      if (!legal && !state.mustPlayAny){
        div.classList.remove("shake");
        void div.offsetWidth;
        div.classList.add("shake");

        const isFace = r => r === "J" || r === "Q" || r === "K";
        const top = topRank();

        let reason = "Illegal move.";
        if (isFace(card.rank) && top && !isFace(top)){
          reason = "Face cards (J/Q/K) can only be played on face cards.";
        } else if (top === "10" || top === "JOKER"){
          reason = "You cannot play on a 10 or Joker (they clear).";
        }

        addLog(`‚ùå ${reason}`, "bad");
        return;
      }

      const now = Date.now();
      const isDouble = (lastTap.id === card.id && (now - lastTap.t) < 320);
      lastTap = { id: card.id, t: now };

      if (isDouble){
        quickPlayRank(card.rank);
        return;
      }

      toggleSelect(card, src);
    };

    return div;
  }

  function toggleSelect(card, src){
    if (selected.has(card.id)){
      selected.delete(card.id);
      selectedSources.delete(card.id);
    } else {
      selected.add(card.id);
      selectedSources.set(card.id, src);
    }
    render();
  }

  function selectedCards(){
    const p = state.players[state.viewPlayer];
    if (!p) return [];
    const all = [];
    for (const [id, src] of selectedSources.entries()){
      let card = null;
      if (src.zone === "hand"){
        card = p.hand.find(c=>c.id===id);
      } else if (src.zone === "tableUp"){
        card = p.tableUp[src.stackIndex];
      } else if (src.zone === "tableDown"){
        card = p.tableDown[src.stackIndex];
      }
      if (card) all.push({card, src});
    }
    return all;
  }

  function validateSelection(playList){
    if (playList.length === 0) return {ok:false, msg:"Select at least one card."};

    const downCount = playList.filter(x=>x.src.zone==="tableDown").length;
    if (downCount > 1) return {ok:false, msg:"Play face-down cards one at a time."};

    if (downCount === 1){
      if (playList.length !== 1) return {ok:false, msg:"Face-down must be played alone."};
      return {ok:true, msg:"Face-down play."};
    }

    const ranks = new Set(playList.map(x=>x.card.rank));
    if (ranks.size !== 1) return {ok:false, msg:"All played cards must be the same rank."};
    const r = playList[0].card.rank;

    if (!canPlayOnTop(r)) return {ok:false, msg:`Illegal play on top (${topRank()}).`};
    return {ok:true, msg:"OK"};
  }

  function removeCardFromSource(player, card, src){
    if (src.zone === "hand"){
      player.hand = player.hand.filter(c=>c.id !== card.id);
    } else if (src.zone === "tableUp"){
      player.tableUp[src.stackIndex] = null;
    } else if (src.zone === "tableDown"){
      player.tableDown[src.stackIndex] = null;
    }
  }

  function pickupPile(player){
    if (state.pile.length === 0){
      addLog(`${player.name} tried to pick up, but pile is empty.`, "warn");
      return;
    }
    shakePile();
    player.hand.push(...state.pile);
    addLog(`${player.name} picks up the pile (${state.pile.length} cards).`, "bad");
    state.pile = [];
    state.mustPlayAny = true;

    mpBroadcast(serializeGameState());
  }

  function playCards(player, playList){
    if (playList.length === 1 && playList[0].src.zone === "tableDown"){
      const {card, src} = playList[0];
      addLog(`${player.name} plays face-down ‚Üí revealed ${renderCardText(card)}.`, "warn");

      if (!canPlayOnTop(card.rank)){
        state.pile.push(card);
        removeCardFromSource(player, card, src);
        render();
        pickupPile(player);
        return {extraTurn:false};
      }

      state.pile.push(card);
      removeCardFromSource(player, card, src);

      if (isTenOrJoker(card)){
        clearPile(`${renderCardText(card)} clears`);
        return {extraTurn:true};
      }
      if (checkTripleClear()){
        clearPile(`triple of ${card.rank}`);
        return {extraTurn:true};
      }
      state.mustPlayAny = false;
      return {extraTurn:false};
    }

    const ranks = new Set(playList.map(x=>x.card.rank));
    if (ranks.size !== 1) return {extraTurn:false};

    const rank = playList[0].card.rank;
    addLog(`${player.name} plays ${playList.length} √ó ${rank}.`);

    for (const {card, src} of playList){
      state.pile.push(card);
      removeCardFromSource(player, card, src);
    }

    if (rank === "10" || rank === "JOKER"){
      clearPile(`${rank} clears`);
      return {extraTurn:true};
    }
    if (checkTripleClear()){
      clearPile(`triple of ${rank}`);
      return {extraTurn:true};
    }

    state.mustPlayAny = false;
    return {extraTurn:false};
  }

  function playerRemaining(player){
    return player.hand.length + player.tableUp.filter(Boolean).length + player.tableDown.filter(Boolean).length;
  }

  function nextPlayer(){
    state.currentPlayer = (state.currentPlayer + 1) % state.numPlayers;
    resetSelection();
    beginTurnRevealFlow();
    mpBroadcast(serializeGameState());
  }

  function isTurnPlayable(){
    // If connected as joiner, disable local play (spectator mode)
    if (mpWs && mpWs.readyState === WebSocket.OPEN && !mpIsHost) return false;

    if (state.gameOver) return false;
    if (!state.revealedThisTurn) return false;
    if (state.viewPlayer !== state.currentPlayer) return false;
    const p = state.players[state.currentPlayer];
    if (!p) return false;
    return p.type === PlayerType.HUMAN;
  }

  function humanPlay(){
    if (!isTurnPlayable()) return;
    if (state.peekOnly) return;

    const p = state.players[state.currentPlayer];
    const playList = selectedCards();
    const v = validateSelection(playList);
    if (!v.ok){
      addLog(`‚ùå ${v.msg}`, "bad");
      return;
    }

    resetSelection();
    const res = playCards(p, playList);
    render();
    if (res.extraTurn) {
      mpBroadcast(serializeGameState());
      return;
    }
    nextPlayer();
  }

  function humanPickup(){
    if (!isTurnPlayable()) return;
    const p = state.players[state.currentPlayer];
    resetSelection();
    pickupPile(p);
    render();
    nextPlayer();
  }

  function humanHint(){
    if (!isTurnPlayable()) return;
    if (state.peekOnly) return;

    const p = state.players[state.currentPlayer];
    const ranks = [];
    const cards = [...p.hand, ...p.tableUp.filter(Boolean)];
    const byRank = new Map();
    for (const c of cards){
      if (!byRank.has(c.rank)) byRank.set(c.rank, []);
      byRank.get(c.rank).push(c);
    }
    for (const r of byRank.keys()){
      if (canPlayOnTop(r)) ranks.push(r);
    }

    if (ranks.length === 0){
      addLog(`Hint: no legal play ‚Üí pick up.`, "warn");
      return;
    }
    if (ranks.includes("10") || ranks.includes("JOKER")){
      addLog(`Hint: 10/Joker clears instantly.`, "ok");
      return;
    }
    const best = ranks.slice().sort((a,b)=> rankOrder(b)-rankOrder(a))[0];
    addLog(`Hint: play ${best}.`, "ok");
  }

  function renderPileVisual(){
    pileVisualWrap.innerHTML = "";
    const slice = state.pile.slice(-6);
    slice.forEach((c, i) => {
      const d = makeRealCardDiv(c, { selectable:false, selectedOn:false, back:false });
      d.classList.add("pileCard");
      const rot = (Math.random()*2-1);
      d.style.transform = `translate(${i*12}px, ${i*4}px) rotate(${rot}deg)`;
      if (i === slice.length-1) d.classList.add("anim-pop");
      pileVisualWrap.appendChild(d);
    });
  }

  function renderPlayersRow(){
    playersRowEl.innerHTML = "";

    const arrow = document.getElementById("turnArrow");
    arrow.style.display = "none";

    state.players.forEach((p, idx) => {
      const chip = document.createElement("div");
      const seat = SEAT_CLASSES[idx] || "";

      chip.className =
        "playerChip " +
        seat +
        (idx === state.currentPlayer ? " active" : " inactive");

      chip.innerHTML = `
        <div class="avatar" style="background:${seatGradient(p.id)}">
          <div class="emo">${p.emoji}</div>
          <div class="init">${p.initials}</div>
        </div>
        <div>
          <div class="pname">${p.name}</div>
        </div>
      `;

      playersRowEl.appendChild(chip);

      if (idx === state.currentPlayer){
        const r = chip.getBoundingClientRect();
        const tableRect = playersRowEl.getBoundingClientRect();

        arrow.style.display = "block";
        arrow.textContent = "‚¨áÔ∏è";
        arrow.style.left = (r.left - tableRect.left + r.width/2 - 10) + "px";
        arrow.style.top  = (r.top - tableRect.top + r.height + 4) + "px";

        if (seat.includes("top")){
          arrow.textContent = "‚¨áÔ∏è";
        } else if (seat.includes("bottom")){
          arrow.textContent = "‚¨ÜÔ∏è";
          arrow.style.top = (r.top - tableRect.top - 28) + "px";
        } else if (seat.includes("left")){
          arrow.textContent = "‚û°Ô∏è";
          arrow.style.left = (r.left - tableRect.left + r.width + 6) + "px";
          arrow.style.top  = (r.top - tableRect.top + r.height/2 - 10) + "px";
        } else if (seat.includes("right")){
          arrow.textContent = "‚¨ÖÔ∏è";
          arrow.style.left = (r.left - tableRect.left - 26) + "px";
          arrow.style.top  = (r.top - tableRect.top + r.height/2 - 10) + "px";
        }
      }
    });
  }

  function renderZonesHidden(){
    yourHandEl.innerHTML = "";
    yourTableEl.innerHTML = "";
    for (let i=0;i<5;i++){
      const back = makeRealCardDiv({rank:"X", suit:""}, {selectable:false, selectedOn:false, back:true});
      back.style.opacity = "0.55";
      yourHandEl.appendChild(back);
    }
    for (let i=0;i<4;i++){
      const back = makeRealCardDiv({rank:"X", suit:""}, {selectable:false, selectedOn:false, back:true});
      back.style.opacity = "0.55";
      yourTableEl.appendChild(back);
    }
  }

  function renderZonesForPlayer(pid){
    const p = state.players[pid];
    if (!p) return;

    el("handLabel").textContent = `${p.name} hand`;
    el("tableLabel").textContent = `${p.name} table`;

    yourHandEl.innerHTML = "";
    if (state.peekOnly){
      for (let i=0;i<5;i++){
        const back = makeRealCardDiv({rank:"X", suit:""}, {selectable:false, selectedOn:false, back:true});
        yourHandEl.appendChild(back);
      }
    } else {
      p.hand.slice().sort((a,b)=>rankSortKey(a.rank)-rankSortKey(b.rank)).forEach(card=>{
        yourHandEl.appendChild(renderSelectableCard(card, {zone:"hand"}));
      });
    }

    yourTableEl.innerHTML = "";
    for (let i=0;i<4;i++){
      const up = p.tableUp[i];
      const down = p.tableDown[i];

      if (up){
        yourTableEl.appendChild(renderSelectableCard(up, {zone:"tableUp", stackIndex:i}));
      } else if (down){
        const back = makeRealCardDiv(down, { selectable:true, selectedOn:selected.has(down.id), back:true });
        back.onclick = () => {
          if (!isTurnPlayable()) return;
          if (selected.has(down.id)){
            selected.delete(down.id);
            selectedSources.delete(down.id);
          } else {
            resetSelection();
            selected.add(down.id);
            selectedSources.set(down.id, {zone:"tableDown", stackIndex:i});
          }
          render();
        };
        yourTableEl.appendChild(back);
      } else {
        const empty = document.createElement("div");
        empty.className = "c back";
        empty.style.opacity = "0.35";
        empty.innerHTML = `<div class="pip" style="color:rgba(255,255,255,.9)">‚Äî</div>`;
        yourTableEl.appendChild(empty);
      }
    }
  }

  function render(){
    el("drawCount").textContent = state.deck.length.toString();
    el("discardCount").textContent = state.discard.length.toString();
    el("pileCount").textContent = state.pile.length.toString();
    el("handInfo").textContent = `Hand ${state.handIndex} / ${state.handsTotal}`;
    el("turnInfo").textContent = `Turn: ${playerName(state.currentPlayer)}`;
    el("topValue").textContent = state.mustPlayAny ? "ANY" : (topRank() ? topRank() : "‚Äî");

    renderPlayersRow();
    renderPileVisual();

    if (!state.revealedThisTurn || state.viewPlayer === null){
      el("handLabel").textContent = `Current player hand`;
      el("tableLabel").textContent = `Current player table`;
      renderZonesHidden();
    } else {
      renderZonesForPlayer(state.viewPlayer);
    }

    const playable = isTurnPlayable();
    el("playBtn").disabled = !playable || state.peekOnly;
    el("pickupBtn").disabled = !playable;
    el("hintBtn").disabled = !playable || state.peekOnly;
    el("playBtnMobile").disabled = !playable || state.peekOnly;
    el("pickupBtnMobile").disabled = !playable;
    el("hintBtnMobile").disabled = !playable || state.peekOnly;
  }

  el("newGame").onclick = () => {
    state.numPlayers = parseInt(el("numPlayers").value, 10);
    state.players = createPlayers(state.numPlayers);
    state.players.forEach((p,i)=> p.initials = initialsFromName(p.name) || `P${i+1}`);
    state.handIndex = 1;
    logEl.innerHTML = "";
    addLog(`New game started with ${state.numPlayers} players.`, "ok");
    dealHand();
  };

  el("newHand").onclick = () => {
    if (state.gameOver){
      addLog(`Game is over. Click "New Game" to restart.`, "warn");
      return;
    }
    dealHand();
  };

  el("playBtn").onclick = humanPlay;
  el("pickupBtn").onclick = humanPickup;
  el("hintBtn").onclick = humanHint;

  el("playBtnMobile").onclick = humanPlay;
  el("pickupBtnMobile").onclick = humanPickup;
  el("hintBtnMobile").onclick = humanHint;

  readyBtn.onclick = () => endOverlayReveal(false);
  peekBtn.onclick = () => endOverlayReveal(true);

  state.numPlayers = parseInt(el("numPlayers").value, 10);
  state.players = createPlayers(state.numPlayers);
  state.players.forEach((p,i)=> p.initials = initialsFromName(p.name) || `P${i+1}`);
  addLog(`Ready. Click "New Game" to begin.`, "ok");
  render();
})();
</script>
</body>
</html>
