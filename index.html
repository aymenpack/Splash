<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Splash</title>

  <style>
    /* =========================
       THEME SYSTEM
       ========================= */
    :root{
      /* layout sizing */
      --card-w: clamp(46px, 8.2vw, 74px);
      --card-h: calc(var(--card-w) * 1.45);
      --pile-h: 112px;
      --panel-h: 180px;
      --radius-xl: 22px;
      --radius-lg: 18px;
      --radius-md: 14px;
      --gap: 10px;

      /* default theme vars (overridden per theme class) */
      --bg0: #0b1220;
      --bg1: #142046;
      --surface: rgba(255,255,255,.05);
      --surface2: rgba(0,0,0,.22);
      --border: rgba(255,255,255,.12);
      --text: #e6edf7;
      --muted: rgba(230,237,247,.72);

      --accent: #63b3ed;
      --accent2: rgba(99,179,237,.18);
      --danger: #ff7b72;
      --ok: #7ee787;

      --table1: #12204a;
      --table2: #0c1430;

      --shadow: 0 10px 26px rgba(0,0,0,.45);
      --shadow2: 0 12px 34px rgba(0,0,0,.55);

      --btn: rgba(255,255,255,.08);
      --btnBorder: rgba(255,255,255,.18);
    }

    /* üåä Ocean (default) */
    body.theme-ocean{
      --bg0:#0b1220; --bg1:#142046;
      --table1:#12204a; --table2:#0c1430;
      --accent:#63b3ed; --accent2:rgba(99,179,237,.18);
      --danger:#ff7b72;
    }

    /* üíú Purple */
    body.theme-purple{
      --bg0:#0a0716; --bg1:#25115a;
      --table1:#2b0e6a; --table2:#120a2d;
      --accent:#b47bff; --accent2:rgba(180,123,255,.18);
      --danger:#ff7b72;
    }

    /* üåµ Desert */
    body.theme-desert{
      --bg0:#0f0d08; --bg1:#2a2011;
      --table1:#3a2a13; --table2:#1a1309;
      --accent:#f2cc60; --accent2:rgba(242,204,96,.18);
      --danger:#ff7b72;
    }

    /* üåø Emerald */
    body.theme-emerald{
      --bg0:#07130f; --bg1:#0f2c22;
      --table1:#10382a; --table2:#081a13;
      --accent:#40e0a0; --accent2:rgba(64,224,160,.18);
      --danger:#ff7b72;
    }

    /* =========================
       GLOBAL / NO SCROLL
       ========================= */
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; overflow:hidden; }
    body{
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(circle at top, var(--bg1), var(--bg0) 62%);
      -webkit-tap-highlight-color: transparent;
    }

    button,input,select{
      background:var(--btn);
      border:1px solid var(--btnBorder);
      color:var(--text);
      padding:10px 12px;
      border-radius:var(--radius-md);
      font-size:14px;
      outline:none;
    }
    button{ cursor:pointer; }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    button.primary{
      background: var(--accent2);
      border-color: color-mix(in srgb, var(--accent) 55%, transparent);
    }
    button.danger{
      background: color-mix(in srgb, var(--danger) 18%, transparent);
      border-color: color-mix(in srgb, var(--danger) 55%, transparent);
    }

    .muted{ color:var(--muted); font-size:12px; }
    .pill{
      padding:5px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      font-size:12px;
      display:inline-flex;
      gap:6px;
      align-items:center;
      white-space:nowrap;
    }

    #app{ height:100%; display:flex; flex-direction:column; }

    /* =========================
       LOBBY
       ========================= */
    #lobbyView{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
    }
    .lobbyCard{
      width:min(620px,100%);
      background:var(--surface);
      border:1px solid var(--border);
      border-radius:var(--radius-xl);
      box-shadow:var(--shadow2);
      padding:18px;
    }
    .lobbyTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom:12px;
    }
    .brand h1{
      margin:0;
      font-size:22px;
      font-weight:950;
      letter-spacing:.2px;
    }
    .brand .sub{
      margin-top:4px;
      color:var(--muted);
      font-size:13px;
      line-height:1.25;
    }
    .lobbyGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .lobbyGrid label{ display:block; font-size:12px; color:var(--muted); margin:0 0 6px; }
    .lobbyGrid input, .lobbyGrid select{ width:100%; }
    .lobbyActions{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:12px;
    }
    .lobbyFooter{
      margin-top:12px;
      padding-top:12px;
      border-top:1px solid rgba(255,255,255,.10);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    @media (max-width: 520px){
      .lobbyGrid{ grid-template-columns:1fr; }
      .lobbyActions{ grid-template-columns:1fr; }
    }

    /* =========================
       GAME
       ========================= */
    #gameView{
      height:100%;
      display:none;
      flex-direction:column;
    }

    header{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      background: color-mix(in srgb, rgba(0,0,0,.35) 70%, transparent);
      backdrop-filter: blur(10px);
    }
    header .left{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      min-width:0;
    }
    header .title{
      font-weight:950;
      letter-spacing:.2px;
      white-space:nowrap;
      font-size:14px;
    }
    header .right{
      margin-left:auto;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    main{
      flex:1;
      min-height:0;
      padding:10px;
      overflow:hidden;
      padding-bottom: calc(var(--panel-h) + 26px + env(safe-area-inset-bottom));
    }

    .table{
      height:100%;
      min-height:0;
      background: linear-gradient(180deg, var(--table1), var(--table2));
      border-radius:var(--radius-xl);
      box-shadow:var(--shadow2);
      padding:12px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .playersRow{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:8px;
      flex:0 0 auto;
    }

    .playerChip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:16px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      min-width:0;
    }
    .playerChip.active{
      outline:2px solid var(--accent);
      box-shadow:0 0 18px color-mix(in srgb, var(--accent) 35%, transparent);
    }
    .avatar{
      width:38px;height:38px;border-radius:50%;
      background:rgba(255,255,255,.9);
      color:#0b1220;
      display:flex;align-items:center;justify-content:center;
      font-weight:900;
      flex:0 0 auto;
      position:relative;
    }
    .avatar .emo{ font-size:18px; }
    .avatar .seat{
      position:absolute;
      bottom:-2px; right:-2px;
      background:#000;
      color:#fff;
      font-size:10px;
      padding:1px 5px;
      border-radius:999px;
    }

    .pileBox{
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      padding:10px;
      flex:0 0 auto;
      overflow:hidden;
    }
    .pileRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .pileVisual{
      width:100%;
      height:var(--pile-h);
      border-radius:16px;
      border:2px dashed rgba(255,255,255,.20);
      background:rgba(0,0,0,.18);
      margin-top:10px;
      position:relative;
      overflow:hidden;
      transition:.15s ease;
    }
    .pileVisual.dragOver{
      border-color:var(--accent);
      background:color-mix(in srgb, var(--accent) 14%, transparent);
    }

    .zoneTitle{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      color:var(--muted);
      font-size:12px;
      flex:0 0 auto;
    }

    /* ---------- Cards ---------- */
    .c{
      width:var(--card-w);
      height:var(--card-h);
      border-radius:12px;
      background:#fff;
      color:#111;
      position:relative;
      box-shadow:0 6px 18px rgba(0,0,0,.45);
      user-select:none;
      touch-action:none;
      transition:.12s ease;
    }
    .c.illegal{ opacity:.55; }
    .c.selected{ outline:3px solid var(--accent); transform:translateY(-3px); }

    .corner{
      position:absolute;
      font-weight:900;
      font-size:12px;
      line-height:1;
    }
    .corner.top{ top:6px; left:6px; }
    .corner.bottom{ bottom:6px; right:6px; transform:rotate(180deg); }
    .pip{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      font-size:28px;
    }

    /* ---------- Hand stacks (5 per row) ---------- */
    .handStacks{
      flex:0 0 auto;
      min-height: 150px;     /* ensures visible */
      max-height: 190px;
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap:8px;
      justify-items:center;
      align-content:start;
      overflow:hidden;
    }
    .cardStack{
      width:var(--card-w);
      height:var(--card-h);
      position:relative;
    }
    .cardStack .c{ position:absolute; top:0; left:0; }
    .stackGhost{
      opacity:.18;
      filter:saturate(.9);
    }
    .stackGhost.g1{ transform: translate(7px, -7px); }
    .stackGhost.g2{ transform: translate(14px, -14px); }
    .stackCount{
      position:absolute;
      top:-6px; right:-6px;
      background:rgba(0,0,0,.82);
      border:1px solid rgba(255,255,255,.18);
      color:#fff;
      font-size:11px;
      padding:2px 7px;
      border-radius:999px;
      font-weight:900;
    }

    /* Table cards row (kept, but we hide it on mobile when hand not empty via JS) */
    .tableCards{
      flex:0 0 auto;
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap:8px;
      justify-items:center;
      overflow:hidden;
    }
    .hidden{ display:none !important; }

    /* ---------- Bottom panel ---------- */
    .panel{
      position:fixed;
      left:10px;
      right:10px;
      bottom: calc(10px + env(safe-area-inset-bottom));
      height:var(--panel-h);
      background: color-mix(in srgb, rgba(15,20,40,.96) 85%, transparent);
      border:1px solid rgba(255,255,255,.14);
      border-radius:var(--radius-xl);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      z-index:1000;
      backdrop-filter: blur(10px);
    }
    .panel .row{ display:flex; gap:10px; }
    .panel button{ flex:1; }
    .panel .metaRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    /* Log drawer inside panel (compact) */
    .logWrap{
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      background:rgba(0,0,0,.22);
      display:flex;
      flex-direction:column;
    }
    .logHead{
      flex:0 0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .logBody{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      padding:8px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
    }
    .logLine{
      padding:2px 0;
      border-bottom:1px dashed rgba(255,255,255,.08);
    }
    .logLine:last-child{ border-bottom:none; }

    /* Snap animation clone */
    .snapClone{
      position:fixed;
      z-index:5000;
      pointer-events:none;
      transition: transform .22s ease, opacity .22s ease;
      transform-origin:center center;
    }

    @media (max-width: 600px){
      :root{
        --pile-h: 100px;
        --panel-h: 170px;
      }
      .corner{ font-size:11px; }
      .pip{ font-size:24px; }
      .handStacks{ min-height:140px; max-height:180px; }
    }
  </style>
</head>

<body class="theme-ocean">
<div id="app">

  <!-- LOBBY -->
  <section id="lobbyView">
    <div class="lobbyCard">
      <div class="lobbyTop">
        <div class="brand">
          <h1>üÉè Splash</h1>
          <div class="sub">Family room. Pick a theme. Enter your name. Play.</div>
        </div>
        <span class="pill" id="lobbyStatus">Not connected</span>
      </div>

      <div class="lobbyGrid">
        <div>
          <label for="nameInput">Your name</label>
          <input id="nameInput" placeholder="Name" />
        </div>
        <div>
          <label for="themeSelectLobby">Theme</label>
          <select id="themeSelectLobby">
            <option value="ocean">Ocean</option>
            <option value="purple">Purple</option>
            <option value="emerald">Emerald</option>
            <option value="desert">Desert</option>
          </select>
        </div>
      </div>

      <div class="lobbyActions">
        <button id="enterBtn" class="primary">Enter Game</button>
        <button id="resetNameBtn">Reset Name</button>
      </div>

      <div class="lobbyFooter">
        <div class="muted">Room is fixed for your family: <b>FAMILY</b> (no codes).</div>
        <div class="muted">In-game: tap a stack to select, drag stack to pile to play (with snap).</div>
      </div>
    </div>
  </section>

  <!-- GAME -->
  <section id="gameView">
    <header>
      <div class="left">
        <div class="title">üÉè Splash</div>
        <span class="pill" id="roomPill">ROOM: ‚Äî</span>
        <span class="pill" id="turnInfo">Turn: ‚Äî</span>
      </div>
      <div class="right">
        <select id="themeSelectGame" title="Theme">
          <option value="ocean">Ocean</option>
          <option value="purple">Purple</option>
          <option value="emerald">Emerald</option>
          <option value="desert">Desert</option>
        </select>
        <button id="newGame" class="primary">New Game</button>
        <button id="leaveBtn" class="danger">Leave</button>
      </div>
    </header>

    <main>
      <div class="table">
        <div class="playersRow" id="playersRow"></div>

        <div class="pileBox">
          <div class="pileRow">
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
              <span class="pill">Deck: <span id="deckCount">‚Äî</span></span>
              <span class="pill">Discard: <span id="discardCount">‚Äî</span></span>
              <span class="pill">Pile: <span id="pileCount">‚Äî</span></span>
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
              <span class="muted">Top:</span>
              <span class="pill" id="topValue">‚Äî</span>
            </div>
          </div>
          <div class="pileVisual" id="pileVisual"></div>
          <div class="muted" style="margin-top:8px;">Tap a stack to select. Drag it onto the pile to play (snap).</div>
        </div>

        <div class="zoneTitle">
          <span>Your hand (grouped)</span>
          <span class="muted" id="turnHint">‚Äî</span>
        </div>
        <div id="handStacks" class="handStacks"></div>

        <div class="zoneTitle" id="tableTitle">
          <span>Your table cards</span>
          <span class="muted">Play hand first</span>
        </div>
        <div id="yourTable" class="tableCards"></div>
      </div>
    </main>

    <div class="panel">
      <div class="row">
        <button id="playBtn" class="primary">Play Selected</button>
        <button id="pickupBtn" class="danger">Pick Up Pile</button>
      </div>

      <div class="metaRow">
        <button id="clearSelBtn">Clear</button>
        <span class="pill" id="selPill" style="flex:1; justify-content:center;">Selected: ‚Äî</span>
      </div>

      <div class="logWrap">
        <div class="logHead">
          <div style="font-weight:900;">Game Log</div>
          <span class="muted">Latest on top</span>
        </div>
        <div id="log" class="logBody"></div>
      </div>
    </div>
  </section>

</div>

<script>
(() => {
  /* =========================
     FIXED FAMILY ROOM
     ========================= */
  const FIXED_ROOM = "FAMILY";

  const WS_BASE = "wss://splash-multiplayer.azimaymen.workers.dev";
  const mpClientId = crypto.randomUUID();

  // Views
  const lobbyView = document.getElementById("lobbyView");
  const gameView = document.getElementById("gameView");

  // Lobby controls
  const nameInput = document.getElementById("nameInput");
  const enterBtn = document.getElementById("enterBtn");
  const resetNameBtn = document.getElementById("resetNameBtn");
  const lobbyStatus = document.getElementById("lobbyStatus");
  const themeSelectLobby = document.getElementById("themeSelectLobby");

  // Game controls
  const themeSelectGame = document.getElementById("themeSelectGame");
  const roomPill = document.getElementById("roomPill");
  const turnInfo = document.getElementById("turnInfo");
  const turnHint = document.getElementById("turnHint");
  const playersRow = document.getElementById("playersRow");
  const pileVisual = document.getElementById("pileVisual");
  const handStacks = document.getElementById("handStacks");
  const yourTable = document.getElementById("yourTable");
  const tableTitle = document.getElementById("tableTitle");
  const logEl = document.getElementById("log");

  const deckCount = document.getElementById("deckCount");
  const discardCount = document.getElementById("discardCount");
  const pileCount = document.getElementById("pileCount");
  const topValue = document.getElementById("topValue");

  const playBtn = document.getElementById("playBtn");
  const pickupBtn = document.getElementById("pickupBtn");
  const newGameBtn = document.getElementById("newGame");
  const leaveBtn = document.getElementById("leaveBtn");
  const clearSelBtn = document.getElementById("clearSelBtn");
  const selPill = document.getElementById("selPill");

  // Multiplayer state
  let mpWs = null;
  let mpConnected = false;
  let mySeat = null;
  let reconnectAttempts = 0;
  let reconnectTimer = null;
  const MAX_RECONNECT_ATTEMPTS = 5;

  // Drag state (stack dragging)
  const drag = { active:false, ids:null, el:null, pid:null, moved:false, sx:0, sy:0 };

  // Game constants
  const SUITS = ["‚ô†", "‚ô•", "‚ô¶", "‚ô£"];
  const RANKS = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
  const RANK_ORDER = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
  const rankOrder = (r) => RANK_ORDER.indexOf(r);
  const isFace = (r) => r === "J" || r === "Q" || r === "K";
  const EMOJIS = ["ü¶ä", "üêº", "üêØ", "ü¶Å", "üê∏", "üêô", "ü¶â", "ü¶Ñ", "üê≤", "üê∂", "üê±", "üêµ"];

  // Game state
  const state = {
    players: [],
    deck: [],
    discard: [],
    pile: [],
    currentPlayer: 0,
    mustPlayAny: false
  };

  let selected = new Set(); // card ids

  /* =========================
     THEME
     ========================= */
  function applyTheme(theme){
    const t = theme || "ocean";
    document.body.classList.remove("theme-ocean","theme-purple","theme-emerald","theme-desert");
    document.body.classList.add("theme-" + t);
    localStorage.setItem("splash_theme", t);
    themeSelectLobby.value = t;
    themeSelectGame.value = t;
  }

  /* =========================
     STORAGE
     ========================= */
  function saveName(name){ localStorage.setItem("splash_name", name); }
  function loadName(){ return localStorage.getItem("splash_name") || ""; }
  function clearName(){ localStorage.removeItem("splash_name"); }

  function setLobbyStatus(text, ok=false){
    lobbyStatus.textContent = text;
    lobbyStatus.style.borderColor = ok ? "rgba(126,231,135,.5)" : "rgba(255,255,255,.14)";
  }

  function showLobby(){
    gameView.style.display = "none";
    lobbyView.style.display = "flex";
  }
  function showGame(){
    lobbyView.style.display = "none";
    gameView.style.display = "flex";
  }

  function logLine(text, tone=""){
    const div = document.createElement("div");
    div.className = "logLine";
    const ts = new Date().toLocaleTimeString();
    div.innerHTML = `<span class="muted">[${ts}]</span> ${tone ? `<span class="${tone}">‚óè</span> ` : ""}${text}`;
    logEl.prepend(div);
  }

  /* =========================
     WS CONNECT
     ========================= */
  function mpConnect(){
    const nm = (nameInput.value || "").trim();
    if (!nm) return alert("Enter your name");
    saveName(nm);

    roomPill.textContent = `ROOM: ${FIXED_ROOM}`;
    setLobbyStatus(`Connecting to ${FIXED_ROOM}‚Ä¶`, false);

    mpWs = new WebSocket(`${WS_BASE}?room=${FIXED_ROOM}`);

    mpWs.onopen = () => {
      mpConnected = true;
      reconnectAttempts = 0;
      setLobbyStatus(`Connected: ${FIXED_ROOM}`, true);

      mpWs.send(JSON.stringify({ type:"join", id: mpClientId, name: nm }));
      showGame();
      logLine(`Connected to room ${FIXED_ROOM}`, "ok");
    };

    mpWs.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "players") {
        mySeat = msg.players.findIndex(p => p.id === mpClientId);
        ensurePlayersFromServer(msg.players);
        render();
      }

      if (msg.type === "state") {
        applyRemoteState(msg.payload?.state);
      }

      if (msg.type === "pong") {}
      if (msg.type === "reset") {
        logLine("Game reset", "warn");
        resetLocalState();
        render();
      }
    };

    mpWs.onclose = () => {
      mpConnected = false;
      setLobbyStatus("Disconnected", false);
      handleReconnect();
    };

    mpWs.onerror = () => {
      mpConnected = false;
      setLobbyStatus("Connection error", false);
    };

    setInterval(() => {
      if (mpWs && mpWs.readyState === WebSocket.OPEN) {
        mpWs.send(JSON.stringify({ type:"ping" }));
      }
    }, 30000);
  }

  function handleReconnect(){
    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      logLine("Failed to reconnect", "bad");
      return;
    }
    reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
    setLobbyStatus(`Reconnecting‚Ä¶ (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, false);
    reconnectTimer = setTimeout(() => mpConnect(), delay);
  }

  function mpSendAction(actionType, nextState){
    if (!mpWs || mpWs.readyState !== WebSocket.OPEN) {
      logLine("Cannot sync - not connected", "warn");
      return;
    }
    mpWs.send(JSON.stringify({
      type: "action",
      action: { type: actionType, state: JSON.parse(JSON.stringify(nextState)) }
    }));
  }

  function mpLeave(){
    if (reconnectTimer) clearTimeout(reconnectTimer);
    if (mpWs) mpWs.close();
    mpWs = null;
    mpConnected = false;
    mySeat = null;
    selected.clear();
    resetLocalState();
    render();
    showLobby();
    setLobbyStatus("Not connected", false);
    logLine("Left room", "warn");
  }

  /* =========================
     GAME LOGIC (original)
     ========================= */
  function ensurePlayersFromServer(players) {
    while (state.players.length < players.length) {
      const idx = state.players.length;
      state.players.push({
        name: `Player ${idx + 1}`,
        emoji: EMOJIS[idx % EMOJIS.length],
        hand: [],
        tableUp: Array.from({ length: 4 }, () => null),
        tableDown: Array.from({ length: 4 }, () => null)
      });
    }
    players.forEach((p, idx) => {
      if (state.players[idx]) state.players[idx].name = p.name || `Player ${idx + 1}`;
    });
  }

  function applyRemoteState(remote) {
    if (!remote) return;
    state.players = remote.players;
    state.deck = remote.deck;
    state.discard = remote.discard;
    state.pile = remote.pile;
    state.currentPlayer = remote.currentPlayer;
    state.mustPlayAny = remote.mustPlayAny;
    selected.clear();
    renderSelectionPill();
    render();
  }

  function resetLocalState() {
    state.deck = [];
    state.discard = [];
    state.pile = [];
    state.currentPlayer = 0;
    state.mustPlayAny = false;
    state.players.forEach(p => {
      p.hand = [];
      p.tableUp = Array.from({ length: 4 }, () => null);
      p.tableDown = Array.from({ length: 4 }, () => null);
    });
  }

  function topRank() {
    return state.pile.length ? state.pile[state.pile.length - 1].rank : null;
  }

  function canPlayOnTop(rank) {
    if (state.mustPlayAny) return true;
    const top = topRank();
    if (!top) return true;
    if (rank === "10" || rank === "JOKER") return true;
    if (top === "10" || top === "JOKER") return false;
    if (isFace(rank) && !isFace(top)) return false;
    return rankOrder(rank) <= rankOrder(top);
  }

  function makeDeck() {
    const d = [];
    for (let k = 0; k < 2; k++) {
      for (const s of SUITS) {
        for (const r of RANKS) d.push({ id: crypto.randomUUID(), rank: r, suit: s });
      }
    }
    for (let j = 0; j < 4; j++) d.push({ id: crypto.randomUUID(), rank: "JOKER", suit: "‚òÖ" });
    for (let i = d.length - 1; i > 0; i--) {
      const k = Math.floor(Math.random() * (i + 1));
      [d[i], d[k]] = [d[k], d[i]];
    }
    return d;
  }

  function isMyTurn() {
    return mySeat !== null && mySeat === state.currentPlayer;
  }

  function newGame() {
    if (!mpConnected) { logLine("Must be connected to start", "bad"); return; }
    if (mySeat !== 0) { logLine("Only Host (Player 1) can start", "warn"); return; }

    state.deck = makeDeck();
    state.discard = [];
    state.pile = [];
    state.mustPlayAny = false;
    state.currentPlayer = 0;

    state.players.forEach(p => {
      p.hand = [];
      p.tableUp = Array.from({ length: 4 }, () => null);
      p.tableDown = Array.from({ length: 4 }, () => null);
    });

    for (let i = 0; i < 4; i++) state.players.forEach(p => p.tableDown[i] = state.deck.pop());
    for (let i = 0; i < 4; i++) state.players.forEach(p => p.tableUp[i] = state.deck.pop());
    for (let i = 0; i < 11; i++) state.players.forEach(p => p.hand.push(state.deck.pop()));

    const start = state.deck.pop();
    state.pile.push(start);
    if (start.rank === "10" || start.rank === "JOKER") {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
    }

    selected.clear();
    renderSelectionPill();
    logLine("Game started by host", "ok");
    mpSendAction("START", state);
    render();
  }

  function playSelected() {
    if (!isMyTurn()) { logLine("Not your turn", "warn"); return; }
    if (mySeat === null) return;
    const me = state.players[mySeat];
    if (!me) return;
    if (!selected.size) return;

    const ids = Array.from(selected);
    const chosen = [];

    for (const id of ids) {
      const h = me.hand.find(c => c.id === id);
      if (h) chosen.push({ card: h, zone: "hand" });
      const upIdx = me.tableUp.findIndex(c => c && c.id === id);
      if (upIdx !== -1) chosen.push({ card: me.tableUp[upIdx], zone: "tableUp", idx: upIdx });
    }
    if (!chosen.length) return;

    const rank = chosen[0].card.rank;
    if (!chosen.every(x => x.card.rank === rank)) { logLine("Must play same rank", "bad"); return; }
    if (!canPlayOnTop(rank)) { logLine("Illegal play - cannot play " + rank + " on " + topRank(), "bad"); return; }

    chosen.forEach(x => {
      if (x.zone === "hand") me.hand = me.hand.filter(c => c.id !== x.card.id);
      if (x.zone === "tableUp") me.tableUp[x.idx] = null;
      state.pile.push(x.card);
    });
    selected.clear();
    renderSelectionPill();

    if (rank === "10" || rank === "JOKER") {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
      logLine("üéâ Clear! Play again", "ok");
      mpSendAction("UPDATE", state);
      render();
      return;
    }

    const cnt = state.pile.reduce((a, c) => a + (c.rank === rank ? 1 : 0), 0);
    if (cnt >= 3) {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
      logLine("üéä Triple clear! Play again", "ok");
      mpSendAction("UPDATE", state);
      render();
      return;
    }

    state.mustPlayAny = false;
    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
    logLine("Played " + rank, "ok");
    mpSendAction("UPDATE", state);
    render();
  }

  function pickup() {
    if (!isMyTurn()) { logLine("Not your turn", "warn"); return; }
    if (mySeat === null) return;
    const me = state.players[mySeat];
    me.hand.push(...state.pile);
    logLine("Picked up " + state.pile.length + " cards", "warn");
    state.pile = [];
    state.mustPlayAny = true;
    selected.clear();
    renderSelectionPill();
    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
    mpSendAction("UPDATE", state);
    render();
  }

  /* =========================
     HAND GROUPING
     ========================= */
  function groupByRank(cards){
    const m = new Map();
    for (const c of cards){
      if (!m.has(c.rank)) m.set(c.rank, []);
      m.get(c.rank).push(c);
    }
    const ranks = Array.from(m.keys()).sort((a,b) => {
      if (a === "JOKER" && b !== "JOKER") return 1;
      if (b === "JOKER" && a !== "JOKER") return -1;
      return RANK_ORDER.indexOf(a) - RANK_ORDER.indexOf(b);
    });
    return ranks.map(r => ({ rank:r, cards:m.get(r) }));
  }

  function renderSelectionPill(){
    if (!selected.size) { selPill.textContent = "Selected: ‚Äî"; return; }
    if (mySeat === null || !state.players[mySeat]) { selPill.textContent = `Selected: ${selected.size}`; return; }
    const me = state.players[mySeat];
    const anyId = selected.values().next().value;
    const anyCard = me.hand.find(x => x.id === anyId) || me.tableUp.find(x => x && x.id === anyId);
    selPill.textContent = anyCard ? `Selected: ${anyCard.rank} √ó ${selected.size}` : `Selected: ${selected.size}`;
  }

  /* =========================
     SNAP ANIMATION
     ========================= */
  function animateElementToPile(fromEl){
    if (!fromEl) return;
    const from = fromEl.getBoundingClientRect();
    const to = pileVisual.getBoundingClientRect();

    const clone = fromEl.cloneNode(true);
    clone.classList.add("snapClone");
    document.body.appendChild(clone);

    clone.style.left = from.left + "px";
    clone.style.top = from.top + "px";
    clone.style.width = from.width + "px";
    clone.style.height = from.height + "px";

    const tx = (to.left + to.width/2) - (from.left + from.width/2);
    const ty = (to.top + to.height/2) - (from.top + from.height/2);

    requestAnimationFrame(() => {
      clone.style.transform = `translate(${tx}px, ${ty}px) scale(.72)`;
      clone.style.opacity = "0";
    });

    setTimeout(() => clone.remove(), 240);
  }

  function animateSelectedToPile(){
    // selected stack (preferred)
    const stack = handStacks.querySelector(".c.selected")?.parentElement;
    if (stack) { animateElementToPile(stack); return; }
    // selected table card
    const card = yourTable.querySelector(".c.selected");
    if (card) animateElementToPile(card);
  }

  /* =========================
     DRAG TO PILE
     ========================= */
  function isOverPile(x,y){
    const r = pileVisual.getBoundingClientRect();
    return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
  }
  function dragStart(ids, el, pid, x, y){
    drag.active = true;
    drag.ids = ids;
    drag.el = el;
    drag.pid = pid;
    drag.moved = false;
    drag.sx = x; drag.sy = y;
    el.setPointerCapture(pid);
  }
  function dragMove(x,y){
    if(!drag.active) return;
    const dx = Math.abs(x - drag.sx);
    const dy = Math.abs(y - drag.sy);
    if (dx + dy > 6) drag.moved = true;
    pileVisual.classList.toggle("dragOver", isOverPile(x,y));
  }
  function dragEnd(x,y){
    if(!drag.active) return;
    pileVisual.classList.remove("dragOver");
    try{ drag.el.releasePointerCapture(drag.pid); }catch{}
    if(drag.moved && isOverPile(x,y)){
      animateElementToPile(drag.el);
      selected.clear();
      drag.ids.forEach(id => selected.add(id));
      renderSelectionPill();
      playSelected();
    }
    drag.active=false; drag.ids=null; drag.el=null; drag.pid=null; drag.moved=false;
  }

  /* =========================
     RENDER
     ========================= */
  function cardHTML(c){
    return `<div class="corner top">${c.rank}<br>${c.suit}</div>
            <div class="pip">${c.suit}</div>
            <div class="corner bottom">${c.rank}<br>${c.suit}</div>`;
  }

  function render(){
    // counters & turn info
    deckCount.textContent = String(state.deck.length);
    discardCount.textContent = String(state.discard.length);
    pileCount.textContent = String(state.pile.length);
    topValue.textContent = state.mustPlayAny ? "ANY" : (topRank() || "‚Äî");
    turnInfo.textContent = "Turn: " + (state.players[state.currentPlayer]?.name || "‚Äî");
    turnHint.textContent = isMyTurn() ? "üëâ Your turn!" : "Waiting‚Ä¶";

    // players
    playersRow.innerHTML = "";
    state.players.forEach((p, idx) => {
      const d = document.createElement("div");
      d.className = "playerChip" + (idx === state.currentPlayer ? " active" : "");
      d.innerHTML = `
        <div class="avatar"><span class="emo">${p.emoji}</span><span class="seat">${idx+1}</span></div>
        <div style="min-width:0">
          <div style="font-weight:900; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${p.name}</div>
          <div class="muted" style="font-size:11px">Hand: ${p.hand.length} | Table: ${p.tableUp.filter(c => c).length}</div>
        </div>`;
      playersRow.appendChild(d);
    });

    // pile visual last 6
    pileVisual.innerHTML = "";
    state.pile.slice(-6).forEach((c, i) => {
      const d = document.createElement("div");
      d.className = "c";
      d.style.position = "absolute";
      d.style.left = "50%";
      d.style.top = `${14 + i * 4}px`;
      d.style.transform = `translateX(-50%) rotate(${i * 4 - 8}deg)`;
      d.innerHTML = cardHTML(c);
      pileVisual.appendChild(d);
    });

    // hand + table
    handStacks.innerHTML = "";
    yourTable.innerHTML = "";

    if (mySeat === null || !state.players[mySeat]) {
      handStacks.innerHTML = '<div class="muted" style="padding:10px;text-align:center;">Join to see your cards</div>';
      renderSelectionPill();
      return;
    }

    const me = state.players[mySeat];

    // grouped hand stacks
    const groups = groupByRank(me.hand);
    groups.forEach(g => {
      const ids = g.cards.map(c => c.id);
      const top = g.cards[g.cards.length - 1];

      const stack = document.createElement("div");
      stack.className = "cardStack";

      if (g.cards.length >= 2){
        const ghost1 = document.createElement("div");
        ghost1.className = "c stackGhost g1";
        ghost1.innerHTML = cardHTML(top);
        stack.appendChild(ghost1);
      }
      if (g.cards.length >= 3){
        const ghost2 = document.createElement("div");
        ghost2.className = "c stackGhost g2";
        ghost2.innerHTML = cardHTML(top);
        stack.appendChild(ghost2);
      }

      const card = document.createElement("div");
      card.className = "c";
      card.innerHTML = cardHTML(top);

      const selectedThisRank = ids.some(id => selected.has(id));
      if (selectedThisRank) card.classList.add("selected");
      if (!canPlayOnTop(g.rank)) card.classList.add("illegal");

      stack.appendChild(card);

      if (g.cards.length > 1){
        const badge = document.createElement("div");
        badge.className = "stackCount";
        badge.textContent = g.cards.length;
        stack.appendChild(badge);
      }

      stack.onclick = () => {
        if (!isMyTurn()) { logLine("Wait for your turn", "warn"); return; }
        if (!canPlayOnTop(g.rank)) { logLine("Cannot play " + g.rank + " on " + topRank(), "bad"); return; }
        const anySelected = ids.some(id => selected.has(id));
        selected.clear();
        if (!anySelected) ids.forEach(id => selected.add(id));
        renderSelectionPill();
        render();
      };

      stack.addEventListener("pointerdown", (e) => {
        if (!isMyTurn()) return;
        if (!canPlayOnTop(g.rank)) return;
        selected.clear();
        ids.forEach(id => selected.add(id));
        renderSelectionPill();
        dragStart(ids, stack, e.pointerId, e.clientX, e.clientY);
      });
      stack.addEventListener("pointermove", (e) => { if(!drag.active) return; dragMove(e.clientX, e.clientY); });
      stack.addEventListener("pointerup",   (e) => { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });
      stack.addEventListener("pointercancel",(e)=> { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });

      handStacks.appendChild(stack);
    });

    // Show/hide table cards on mobile when hand not empty
    const isSmall = window.matchMedia("(max-width: 600px)").matches;
    const showTable = !isSmall || (me.hand.length === 0);
    yourTable.classList.toggle("hidden", !showTable);
    tableTitle.classList.toggle("hidden", !showTable);

    // tableUp cards (only meaningful when hand empty)
    for (let i = 0; i < 4; i++){
      const up = me.tableUp[i];
      if (up){
        const d = document.createElement("div");
        d.className = "c";
        if (!canPlayOnTop(up.rank)) d.classList.add("illegal");
        if (selected.has(up.id)) d.classList.add("selected");
        d.innerHTML = cardHTML(up);

        d.onclick = () => {
          if (!isMyTurn()) { logLine("Wait for your turn", "warn"); return; }
          if (me.hand.length > 0) { logLine("Must play hand first", "warn"); return; }
          if (!canPlayOnTop(up.rank)) { logLine("Cannot play " + up.rank + " on " + topRank(), "bad"); return; }
          selected.clear();
          selected.add(up.id);
          renderSelectionPill();
          render();
        };

        d.addEventListener("pointerdown", (e) => {
          if (!isMyTurn()) return;
          if (me.hand.length > 0) return;
          if (!canPlayOnTop(up.rank)) return;
          selected.clear();
          selected.add(up.id);
          renderSelectionPill();
          dragStart([up.id], d, e.pointerId, e.clientX, e.clientY);
        });
        d.addEventListener("pointermove", (e) => { if(!drag.active) return; dragMove(e.clientX, e.clientY); });
        d.addEventListener("pointerup",   (e) => { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });
        d.addEventListener("pointercancel",(e)=> { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });

        yourTable.appendChild(d);
      } else {
        const empty = document.createElement("div");
        empty.className = "c";
        empty.style.opacity = "0.18";
        empty.innerHTML = `<div class="pip">‚Äî</div>`;
        yourTable.appendChild(empty);
      }
    }
    // filler for 5 columns
    const filler = document.createElement("div");
    filler.style.width = "var(--card-w)";
    filler.style.height = "var(--card-h)";
    filler.style.opacity = "0";
    yourTable.appendChild(filler);

    // buttons
    newGameBtn.disabled = (mySeat !== 0 || !mpConnected);
    playBtn.disabled = (!isMyTurn() || !mpConnected || !selected.size);
    pickupBtn.disabled = (!isMyTurn() || !mpConnected);

    renderSelectionPill();
  }

  /* =========================
     UI WIRING
     ========================= */
  enterBtn.onclick = mpConnect;
  resetNameBtn.onclick = () => { clearName(); nameInput.value = ""; };

  leaveBtn.onclick = mpLeave;
  clearSelBtn.onclick = () => { selected.clear(); renderSelectionPill(); render(); };
  playBtn.onclick = () => { animateSelectedToPile(); playSelected(); };
  pickupBtn.onclick = pickup;
  newGameBtn.onclick = newGame;

  themeSelectLobby.onchange = () => applyTheme(themeSelectLobby.value);
  themeSelectGame.onchange = () => applyTheme(themeSelectGame.value);

  window.addEventListener("resize", () => render());

  /* =========================
     INIT
     ========================= */
  const savedTheme = localStorage.getItem("splash_theme") || "ocean";
  applyTheme(savedTheme);

  const savedName = loadName();
  if (savedName) nameInput.value = savedName;

  setLobbyStatus("Not connected", false);
  showLobby();
  logLine("Welcome! Enter your name and tap Enter Game.", "ok");
})();
</script>
</body>
</html>
