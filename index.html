<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Splash Practice (House Rules)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background:#0b1220; color:#e6edf7; }
    header { padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,.08); display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
    header h1 { font-size: 16px; margin:0; font-weight:700; letter-spacing:.2px; }
    .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    select, button, input {
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      color: #e6edf7;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 13px;
      outline: none;
    }
    button { cursor:pointer; }
    button.primary { background: rgba(99, 179, 237, .18); border-color: rgba(99, 179, 237, .35); }
    button.danger { background: rgba(239,68,68,.16); border-color: rgba(239,68,68,.35); }
    button:disabled { opacity:.5; cursor:not-allowed; }

    main { padding: 14px 16px 22px; max-width: 1200px; margin: 0 auto; }

    .grid { display:grid; gap:12px; grid-template-columns: 360px 1fr; }
    @media (max-width: 980px){ .grid { grid-template-columns: 1fr; } }

    .card { background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.10); border-radius: 16px; padding: 12px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .muted { color: rgba(230,237,247,.72); font-size: 12px; }
    .small { font-size: 12px; }
    .pill { padding: 4px 8px; border-radius: 999px; border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.04); font-size: 12px; }

    .zoneTitle { font-size: 12px; letter-spacing:.2px; color: rgba(230,237,247,.78); margin: 10px 0 6px; display:flex; justify-content:space-between; align-items:center; }
    .hand { display:flex; flex-wrap:wrap; gap:8px; }
    .c {
      min-width: 44px;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:2px;
      user-select:none;
    }
    .c.selectable { cursor:pointer; }
    .c.selected { outline: 2px solid rgba(99,179,237,.65); background: rgba(99,179,237,.14); }
    .c .rank { font-weight:800; }
    .c .suit { font-size: 12px; opacity: .85; }
    .c.back { background: rgba(255,255,255,.03); border-style:dashed; }
    .c.illegal { opacity:.55; }

    .pile {
      display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    }
    .pileTop { font-size: 14px; }
    .log { max-height: 360px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px; line-height: 1.35; background: rgba(0,0,0,.22); border:1px solid rgba(255,255,255,.10);
      border-radius: 14px; padding: 10px;
    }
    .log .line { padding: 2px 0; border-bottom: 1px dashed rgba(255,255,255,.07); }
    .log .line:last-child { border-bottom: none; }

    .players { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:10px; }
    @media (max-width: 820px){ .players { grid-template-columns: 1fr; } }
    .p { padding:10px; border-radius: 14px; border:1px solid rgba(255,255,255,.10); background: rgba(255,255,255,.03); }
    .p.active { outline: 2px solid rgba(99,179,237,.50); }
    .p h3 { margin:0; font-size: 13px; display:flex; justify-content:space-between; align-items:center; }
    .p .stats { margin-top:6px; display:flex; gap:8px; flex-wrap:wrap; }
    .kbd { font-family: ui-monospace, Menlo, monospace; font-size: 11px; padding:2px 6px; border-radius: 8px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); }
    .note { margin-top:10px; padding:10px; border-radius:14px; border:1px solid rgba(255,255,255,.10); background: rgba(255,255,255,.03); }
    .ok { color:#7ee787; }
    .warn { color:#f2cc60; }
    .bad { color:#ff7b72; }
  </style>
</head>
<body>
<header>
  <h1>üÉè Splash Practice (House Rules)</h1>
  <div class="controls">
    <label class="muted">Players</label>
    <select id="numPlayers">
      <option>3</option><option selected>4</option><option>5</option><option>6</option>
    </select>
    <button id="newGame" class="primary">New Game (5 hands)</button>
    <button id="newHand">New Hand</button>
    <span class="pill" id="handInfo">Hand 1 / 5</span>
    <span class="pill" id="turnInfo">Turn: ‚Äî</span>
  </div>
</header>

<main>
  <div class="grid">
    <section class="card">
      <div class="row" style="justify-content:space-between;">
        <div>
          <div class="muted">Your controls</div>
          <div class="small">Select cards (same value) from your hand + face-up stacks, then play.</div>
        </div>
        <div class="row">
          <button id="playBtn" class="primary">Play Selected</button>
          <button id="pickupBtn" class="danger">Pick Up Pile</button>
          <button id="hintBtn">Hint</button>
        </div>
      </div>

      <div class="note">
        <div class="row" style="justify-content:space-between;">
          <div class="pile">
            <div class="pill">Draw: <span id="drawCount">‚Äî</span></div>
            <div class="pill">Discard: <span id="discardCount">‚Äî</span></div>
            <div class="pill">Pile: <span id="pileCount">‚Äî</span></div>
          </div>
          <div class="pileTop">
            Top Value: <span class="pill" id="topValue">‚Äî</span>
          </div>
        </div>
        <div class="muted" style="margin-top:8px;">
          Clears: <span class="kbd">10</span> and <span class="kbd">Joker</span> clear instantly. <span class="kbd">3+</span> of same value on pile clears. Clears go to discard. After a clear you play again with any value.
        </div>
      </div>

      <div class="zoneTitle">
        <span>Your Hand</span>
        <span class="muted">Click cards to select</span>
      </div>
      <div id="yourHand" class="hand"></div>

      <div class="zoneTitle">
        <span>Your Table (4 stacks)</span>
        <span class="muted">You can select face-up cards; face-down are discovered when played</span>
      </div>
      <div id="yourTable" class="hand"></div>

      <div class="zoneTitle">
        <span>Actions</span>
        <span class="muted">Shortcuts: <span class="kbd">Enter</span> play, <span class="kbd">P</span> pickup, <span class="kbd">H</span> hint</span>
      </div>
      <div class="muted">
        Use <b>Pick Up Pile</b> only if you truly have no legal play (or want to practice discipline).
      </div>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between;">
        <div>
          <div class="muted">Table / opponents</div>
          <div class="small">Bots play fast but follow the rules. This is for reps + pattern learning.</div>
        </div>
      </div>

      <div class="players" id="playersPanel"></div>

      <div class="zoneTitle">
        <span>Game Log</span>
        <span class="muted">Newest at top</span>
      </div>
      <div id="log" class="log"></div>
    </section>
  </div>
</main>

<script>
(() => {
  // ======= Card model =======
  const SUITS = ["‚ô†","‚ô•","‚ô¶","‚ô£"];
  const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const isJoker = c => c.rank === "JOKER";
  const isTenOrJoker = c => isJoker(c) || c.rank === "10";

  // "Play value" mapping for comparisons (lower-or-equal allowed)
  // Jokers and 10 are wild; for validation we handle separately.
  const playValue = (rank) => {
    if (rank === "A") return 1;
    if (rank === "J" || rank === "Q" || rank === "K") return 10;
    if (rank === "10") return 10; // special handling anyway
    return parseInt(rank, 10);
  };

  // Scoring values (house)
  const scoreValue = (card) => {
    if (isJoker(card)) return 50;
    if (card.rank === "10") return 20;
    if (card.rank === "A") return 1;
    if (card.rank === "J" || card.rank === "Q" || card.rank === "K") return 10;
    return parseInt(card.rank, 10);
  };

  // For triple detection: need a "value class" for each card when played.
  // If player plays 10/Joker as wild, they must choose what value it represents (except when clearing instantly).
  // We'll store played cards on pile with a field pileValue (1..13 or "JOKER10"?) - we use numbers: A=1, 2..9, 10, J/Q/K all considered 10 for comparison.
  // House rule says "same value" meaning rank, but also you treat J/Q/K as 10 points; for play comparisons you likely treat them as their rank.
  // You described "same value" on table -> same card value. We'll implement value by rank symbol:
  // A,2..10,J,Q,K, plus wild. Triple counts matching rank symbols; wild must declare which rank it counts as if not used to clear.
  const rankKey = (card) => isJoker(card) ? "JOKER" : card.rank;

  // When playing, player selects a "groupRank" which must match among selected.
  // If group is "10" or "JOKER" and they want to clear, allowed.
  // Otherwise wild can be used to represent a chosen rank; we provide UI selection only for face-down wild discoveries.
  // To keep practice smooth: we treat 10/Joker always as clear (your house: "10 acts like a joker").
  // So we don't let wild represent other ranks‚Äîbecause in your rules, 10/Joker clears by itself anyway.
  // It can still contribute to triples if played together (but it would clear immediately anyway). We'll resolve by: 10/Joker always triggers clear immediately.

  // ======= Game State =======
  const state = {
    numPlayers: 4,
    players: [],
    deck: [],
    discard: [],
    pile: [],
    pileTopRank: null, // rank string
    handIndex: 1,
    handsTotal: 5,
    currentPlayer: 0,
    mustPlayAny: false, // after a clear, player can play anything (no top constraint)
    gameOver: false,
  };

  const el = (id) => document.getElementById(id);
  const logEl = el("log");
  const yourHandEl = el("yourHand");
  const yourTableEl = el("yourTable");
  const playersPanelEl = el("playersPanel");

  // Selection model for human player
  let selected = new Set(); // card ids
  let selectedSources = new Map(); // cardId -> {zone, stackIndex?}
  let uid = 0;
  const newId = () => (++uid).toString();

  function makeDeck(){
    const deck = [];
    // 2 standard decks
    for (let d=0; d<2; d++){
      for (const s of SUITS){
        for (const r of RANKS){
          deck.push({ id:newId(), rank:r, suit:s });
        }
      }
    }
    // Jokers: common is 4 jokers total. We'll add 4.
    for (let j=0; j<4; j++){
      deck.push({ id:newId(), rank:"JOKER", suit:"‚òÖ" });
    }
    // shuffle
    for (let i=deck.length-1;i>0;i--){
      const k = Math.floor(Math.random()*(i+1));
      [deck[i], deck[k]] = [deck[k], deck[i]];
    }
    return deck;
  }

  function addLog(text, tone=""){
    const div = document.createElement("div");
    div.className = "line";
    div.innerHTML = `${tone ? `<span class="${tone}">‚óè</span> ` : ""}${text}`;
    logEl.prepend(div);
  }

  function playerName(i){ return i===0 ? "You" : `Bot ${i}`; }

  function createPlayers(n){
    const players = [];
    for (let i=0;i<n;i++){
      players.push({
        id:i,
        hand: [],
        tableUp: Array.from({length:4}, ()=>null),
        tableDown: Array.from({length:4}, ()=>null),
        score: 0,
        outThisHand: false,
        wonHands: 0
      });
    }
    return players;
  }

  function resetSelection(){
    selected.clear();
    selectedSources.clear();
  }

  function topRank(){
    // pile top rank is last card rank (actual card rank)
    const top = state.pile[state.pile.length-1];
    return top ? top.rank : state.pileTopRank; // should exist once started
  }

  function canPlayOnTop(rank){
    if (state.mustPlayAny) return true;
    const top = topRank();
    if (!top) return true;
    // 10/Joker always allowed because clears
    if (rank === "10" || rank === "JOKER") return true;
    // Compare playValue(rank) <= playValue(top) (with top handling)
    return playValue(rank) <= playValue(top === "JOKER" ? "10" : top);
  }

  function countRankOnPile(rank){
    // Count occurrences of rank symbol (exact) among pile cards
    return state.pile.reduce((acc,c)=> acc + (c.rank === rank ? 1 : 0), 0);
  }

  function checkTripleClear(){
    if (state.pile.length < 3) return false;
    // Only need to check the last played rank and see if >=3 exist
    const last = state.pile[state.pile.length-1];
    const r = last.rank;
    if (r === "JOKER") return false; // joker already clears by itself, but we won't double-trigger
    const cnt = countRankOnPile(r);
    return cnt >= 3;
  }

  function clearPile(reason){
    const n = state.pile.length;
    if (n === 0) return;
    state.discard.push(...state.pile);
    state.pile = [];
    state.mustPlayAny = true; // after clear, current player plays again with any value
    addLog(`Pile cleared (${reason}). ${n} cards to discard. Current player plays again (any value).`, "ok");
  }

  function drawStartCard(){
    // flip one card from draw pile onto pile and set top
    const c = state.deck.pop();
    state.pile.push(c);
    state.pileTopRank = c.rank;
    state.mustPlayAny = false;
    addLog(`Start card flipped: ${renderCardText(c)}.`);
  }

  function dealHand(){
    resetSelection();
    state.deck = makeDeck();
    state.discard = [];
    state.pile = [];
    state.mustPlayAny = false;
    state.gameOver = false;

    for (const p of state.players){
      p.hand = [];
      p.tableUp = Array.from({length:4}, ()=>null);
      p.tableDown = Array.from({length:4}, ()=>null);
      p.outThisHand = false;
    }

    // Deal table down: 4 each
    for (let i=0;i<4;i++){
      for (const p of state.players){
        p.tableDown[i] = state.deck.pop();
      }
    }
    // Deal table up: 4 each
    for (let i=0;i<4;i++){
      for (const p of state.players){
        p.tableUp[i] = state.deck.pop();
      }
    }
    // Deal hands: 11 each
    for (let i=0;i<11;i++){
      for (const p of state.players){
        p.hand.push(state.deck.pop());
      }
    }

    // start pile
    drawStartCard();

    // start player index (we‚Äôll just start at 0 for practice; you can adjust to dealer-left later)
    state.currentPlayer = 0;
    addLog(`New hand dealt. You start.`, "ok");
    render();
  }

  function renderCardText(c){
    if (isJoker(c)) return "JOKER";
    return `${c.rank}${c.suit}`;
  }

  function render(){
    el("drawCount").textContent = state.deck.length.toString();
    el("discardCount").textContent = state.discard.length.toString();
    el("pileCount").textContent = state.pile.length.toString();
    el("handInfo").textContent = `Hand ${state.handIndex} / ${state.handsTotal}`;
    el("turnInfo").textContent = `Turn: ${playerName(state.currentPlayer)}`;
    el("topValue").textContent = state.mustPlayAny ? "ANY" : (topRank() ? topRank() : "‚Äî");

    // Players panel
    playersPanelEl.innerHTML = "";
    state.players.forEach((p, idx) => {
      const div = document.createElement("div");
      div.className = "p" + (idx === state.currentPlayer ? " active" : "");
      const remaining = p.hand.length + p.tableUp.filter(Boolean).length + p.tableDown.filter(Boolean).length;
      div.innerHTML = `
        <h3>${playerName(idx)} <span class="pill">${p.score} pts</span></h3>
        <div class="stats">
          <span class="pill">Hand: ${p.hand.length}</span>
          <span class="pill">Up: ${p.tableUp.filter(Boolean).length}</span>
          <span class="pill">Down: ${p.tableDown.filter(Boolean).length}</span>
          <span class="pill">Total: ${remaining}</span>
        </div>
      `;
      playersPanelEl.appendChild(div);
    });

    // Render human hand
    yourHandEl.innerHTML = "";
    const you = state.players[0];

    you.hand
      .slice()
      .sort((a,b) => (rankSortKey(a.rank) - rankSortKey(b.rank)))
      .forEach(card => {
        yourHandEl.appendChild(renderSelectableCard(card, {zone:"hand"}));
      });

    // Render table stacks
    yourTableEl.innerHTML = "";
    for (let i=0;i<4;i++){
      const up = you.tableUp[i];
      const down = you.tableDown[i];

      if (up){
        yourTableEl.appendChild(renderSelectableCard(up, {zone:"tableUp", stackIndex:i}));
      } else {
        // show face-down if exists, playable (discover on play)
        if (down){
          const back = document.createElement("div");
          back.className = "c selectable back" + (selected.has(down.id) ? " selected" : "");
          back.innerHTML = `<div class="rank">üÇ†</div><div class="suit">Down</div>`;
          back.onclick = () => toggleSelect(down, {zone:"tableDown", stackIndex:i}, true);
          yourTableEl.appendChild(back);
        } else {
          const empty = document.createElement("div");
          empty.className = "c back";
          empty.innerHTML = `<div class="rank">‚Äî</div><div class="suit">Empty</div>`;
          yourTableEl.appendChild(empty);
        }
      }
    }

    // Buttons enabled only on your turn
    const yourTurn = state.currentPlayer === 0 && !state.gameOver;
    el("playBtn").disabled = !yourTurn;
    el("pickupBtn").disabled = !yourTurn;
    el("hintBtn").disabled = !yourTurn;
  }

  function rankSortKey(r){
    // sort for display only
    if (r === "JOKER") return 99;
    if (r === "A") return 1;
    if (r === "2") return 2;
    if (r === "3") return 3;
    if (r === "4") return 4;
    if (r === "5") return 5;
    if (r === "6") return 6;
    if (r === "7") return 7;
    if (r === "8") return 8;
    if (r === "9") return 9;
    if (r === "10") return 10;
    if (r === "J") return 11;
    if (r === "Q") return 12;
    if (r === "K") return 13;
    return 50;
  }

  function renderSelectableCard(card, src){
    const div = document.createElement("div");
    const selectable = true;
    div.className = "c selectable" + (selected.has(card.id) ? " selected" : "");
    div.innerHTML = `
      <div class="rank">${isJoker(card) ? "JOKER" : card.rank}</div>
      <div class="suit">${isJoker(card) ? "‚òÖ" : card.suit}</div>
    `;
    div.onclick = () => toggleSelect(card, src, false);
    // mark illegal if single-card would be illegal (helpful visual)
    const legal = canPlayOnTop(card.rank);
    if (!legal && !state.mustPlayAny) div.classList.add("illegal");
    return div;
  }

  function toggleSelect(card, src, isFaceDown){
    // Face-down selection allowed only if its up is empty (we only render it then)
    if (selected.has(card.id)){
      selected.delete(card.id);
      selectedSources.delete(card.id);
    } else {
      selected.add(card.id);
      selectedSources.set(card.id, {...src, isFaceDown});
    }
    render();
  }

  function selectedCards(){
    const you = state.players[0];
    const all = [];
    // Gather cards by searching in zones
    for (const [id, src] of selectedSources.entries()){
      let card = null;
      if (src.zone === "hand"){
        card = you.hand.find(c=>c.id===id);
      } else if (src.zone === "tableUp"){
        card = you.tableUp[src.stackIndex];
      } else if (src.zone === "tableDown"){
        card = you.tableDown[src.stackIndex];
      }
      if (card) all.push({card, src});
    }
    return all;
  }

  function validateSelection(playList){
    if (playList.length === 0) return {ok:false, msg:"Select at least one card."};

    // If any selected is face-down, you can only play ONE face-down at a time (common in discover-on-play games).
    // Your rules didn‚Äôt explicitly say, but it avoids weird multi-flip advantage.
    const downCount = playList.filter(x=>x.src.zone==="tableDown").length;
    if (downCount > 1) return {ok:false, msg:"House rule: play face-down cards one at a time (discover-on-play)."};

    // Determine rank grouping:
    // If a face-down is selected, we don't know its rank until revealed; we allow the action, and if illegal, pickup happens.
    if (downCount === 1){
      // You may still select extra known cards? House said you can play face-up with hand, but for face-down it must be discovered when played.
      // We'll enforce: face-down must be played alone (clean, consistent, and matches the spirit).
      if (playList.length !== 1) return {ok:false, msg:"Face-down card must be played alone (it‚Äôs discovered when played)."};
      return {ok:true, msg:"Face-down play (will be revealed)."};
    }

    // Known cards: all must have same rank
    const ranks = new Set(playList.map(x=>x.card.rank));
    if (ranks.size !== 1) return {ok:false, msg:"All played cards must be the same value (same rank)."};
    const r = playList[0].card.rank;

    // Must be legal relative to pile (unless mustPlayAny)
    if (!canPlayOnTop(r)) return {ok:false, msg:`Illegal: you must play ‚â§ top (${topRank()}) unless you clear and get ANY.`};

    return {ok:true, msg:"OK"};
  }

  function removeCardFromSource(player, card, src){
    if (src.zone === "hand"){
      player.hand = player.hand.filter(c=>c.id !== card.id);
    } else if (src.zone === "tableUp"){
      player.tableUp[src.stackIndex] = null;
    } else if (src.zone === "tableDown"){
      // when played, remove the face-down from that stack
      player.tableDown[src.stackIndex] = null;
    }
  }

  function pickupPile(player){
    if (state.pile.length === 0){
      addLog(`${playerName(player.id)} tried to pick up, but pile is empty.`, "warn");
      return;
    }
    player.hand.push(...state.pile);
    addLog(`${playerName(player.id)} picks up the pile (${state.pile.length} cards).`, "bad");
    state.pile = [];
    state.mustPlayAny = false; // after pickup, next player plays on empty pile? We'll treat empty pile as ANY.
    // On empty pile, we allow any card; we‚Äôll set mustPlayAny true for next player convenience.
    state.mustPlayAny = true;
  }

  function playCards(player, playList){
    // playList: [{card,src}]
    // If face-down play, reveal then decide legality
    if (playList.length === 1 && playList[0].src.zone === "tableDown"){
      const {card, src} = playList[0];
      // Reveal now (card object already exists, just unknown to user; we show it in log)
      addLog(`${playerName(player.id)} plays face-down ‚Üí revealed ${renderCardText(card)}.`);
      // Check legality
      if (!canPlayOnTop(card.rank)){
        // illegal ‚Üí pick up entire pile including revealed card (entire played pile)
        // First, put revealed on pile (it was "played"), then pick up all.
        state.pile.push(card);
        removeCardFromSource(player, card, src);
        pickupPile(player);
        state.mustPlayAny = true; // next player can play anything on empty pile
        return {cleared:false, extraTurn:false, endedByPickup:true};
      } else {
        // legal play
        state.pile.push(card);
        removeCardFromSource(player, card, src);

        // 10/Joker clear instantly
        if (isTenOrJoker(card)){
          clearPile(`${renderCardText(card)} clears`);
          return {cleared:true, extraTurn:true, endedByPickup:false};
        }
        // triple clear
        if (checkTripleClear()){
          clearPile(`triple of ${card.rank}`);
          return {cleared:true, extraTurn:true, endedByPickup:false};
        }
        state.mustPlayAny = false;
        return {cleared:false, extraTurn:false, endedByPickup:false};
      }
    }

    // Known selection
    const rank = playList[0].card.rank;
    const count = playList.length;
    addLog(`${playerName(player.id)} plays ${count} √ó ${rank}${rank==="JOKER" ? "" : ""}.`);

    // Move cards to pile
    for (const {card, src} of playList){
      state.pile.push(card);
      removeCardFromSource(player, card, src);
    }

    // Clear conditions
    if (rank === "10" || rank === "JOKER"){
      clearPile(`${rank} clears`);
      return {cleared:true, extraTurn:true, endedByPickup:false};
    }
    if (checkTripleClear()){
      clearPile(`triple of ${rank}`);
      return {cleared:true, extraTurn:true, endedByPickup:false};
    }

    state.mustPlayAny = false;
    return {cleared:false, extraTurn:false, endedByPickup:false};
  }

  function playerRemaining(player){
    return player.hand.length + player.tableUp.filter(Boolean).length + player.tableDown.filter(Boolean).length;
  }

  function endHandIfNeeded(){
    // if someone has 0 remaining ‚Üí hand ends immediately (as you described)
    const winner = state.players.find(p => playerRemaining(p) === 0);
    if (!winner) return false;

    addLog(`üèÅ ${playerName(winner.id)} wins the hand!`, "ok");

    // Score others
    state.players.forEach(p => {
      if (p.id === winner.id) return;
      const remainingCards = [
        ...p.hand,
        ...p.tableUp.filter(Boolean),
        ...p.tableDown.filter(Boolean)
      ];
      const pts = remainingCards.reduce((sum,c)=>sum+scoreValue(c),0);
      p.score += pts;
      addLog(`${playerName(p.id)} scores ${pts} points (remaining cards).`, "warn");
    });

    // Advance hand
    if (state.handIndex >= state.handsTotal){
      state.gameOver = true;
      const standings = state.players
        .map(p => ({id:p.id, name:playerName(p.id), score:p.score}))
        .sort((a,b)=>a.score-b.score);

      addLog(`üéâ Game over. Winner: ${standings[0].name} with ${standings[0].score} points.`, "ok");
    } else {
      state.handIndex += 1;
      addLog(`Next: Hand ${state.handIndex} / ${state.handsTotal}. Click "New Hand".`, "ok");
    }
    render();
    return true;
  }

  function nextPlayer(){
    state.currentPlayer = (state.currentPlayer + 1) % state.numPlayers;
    render();
  }

  function computeLegalPlays(player){
    // Returns list of ranks that can be played (from hand + face-up). Face-down excluded from "legal plays" check.
    const ranks = [];
    const addRank = (r) => { if (!ranks.includes(r)) ranks.push(r); };

    // Collect all playable cards (hand + face-up)
    const cards = [...player.hand, ...player.tableUp.filter(Boolean)];
    const byRank = new Map();
    for (const c of cards){
      const r = c.rank;
      if (!byRank.has(r)) byRank.set(r, []);
      byRank.get(r).push(c);
    }

    for (const r of byRank.keys()){
      if (canPlayOnTop(r)) addRank(r);
    }
    return {ranks, byRank};
  }

  function botTakeTurn(bot){
    if (state.gameOver) return;

    // If pile empty or mustPlayAny -> bots choose something reasonable.
    const {ranks, byRank} = computeLegalPlays(bot);

    // If no legal from known cards, bot picks up pile (as per your rule)
    if (ranks.length === 0){
      // If bot has no hand/up but has available face-down stacks (no up on them), it must play face-down (discover)
      const anyUp = bot.tableUp.some(Boolean);
      const anyHandOrUp = bot.hand.length > 0 || anyUp;
      if (!anyHandOrUp){
        // play a random available face-down (stack where up is null and down exists)
        const candidates = bot.tableDown.map((c,i)=>({c,i})).filter(x=>x.c && !bot.tableUp[x.i]);
        if (candidates.length > 0){
          const pick = candidates[Math.floor(Math.random()*candidates.length)];
          const res = playCards(bot, [{card: pick.c, src:{zone:"tableDown", stackIndex: pick.i}}]);
          if (endHandIfNeeded()) return;
          if (res.extraTurn) return botTakeTurn(bot);
          nextPlayer();
          return;
        }
      }
      pickupPile(bot);
      nextPlayer();
      return;
    }

    // Bot strategy (simple but decent):
    // 1) Prefer instant clear (10/JOKER) if it avoids pickup or creates advantage
    // 2) Prefer making a triple if possible (play enough copies)
    // 3) Otherwise play the highest legal rank (still <= top) to restrict others
    // Note: "highest" under the ‚â§ constraint means closest to top without going over.

    const top = state.mustPlayAny ? null : topRank();

    const legalRanks = ranks.slice();

    const hasClear = legalRanks.includes("10") || legalRanks.includes("JOKER");
    if (hasClear){
      // sometimes don‚Äôt waste a Joker if you can triple-clear; but we‚Äôll keep it simple
      const r = legalRanks.includes("10") ? "10" : "JOKER";
      const cards = byRank.get(r);
      // play 1 of them
      const c = cards[0];
      const src = bot.hand.find(x=>x.id===c.id) ? {zone:"hand"} : {zone:"tableUp", stackIndex: bot.tableUp.findIndex(x=>x && x.id===c.id)};
      const res = playCards(bot, [{card:c, src}]);
      if (endHandIfNeeded()) return;
      if (res.extraTurn) return botTakeTurn(bot);
      nextPlayer();
      return;
    }

    // try triple clear: if byRank has >=3 of some legal rank, play enough to clear
    for (const r of legalRanks){
      if (r==="10" || r==="JOKER") continue;
      const cards = byRank.get(r);
      // Need total >=3 on pile after play (pile may already contain some)
      const existing = countRankOnPile(r);
      const needed = Math.max(0, 3 - existing);
      if (needed > 0 && cards.length >= needed){
        const toPlay = cards.slice(0, needed);
        const playList = toPlay.map(c => ({
          card: c,
          src: bot.hand.find(x=>x.id===c.id) ? {zone:"hand"} : {zone:"tableUp", stackIndex: bot.tableUp.findIndex(x=>x && x.id===c.id)}
        }));
        const res = playCards(bot, playList);
        if (endHandIfNeeded()) return;
        if (res.extraTurn) return botTakeTurn(bot);
        nextPlayer();
        return;
      }
      if (existing >= 3){
        // already triple, but it would have cleared earlier; ignore
      }
    }

    // Otherwise pick "highest legal" rank under comparison (when mustPlayAny, pick something low-penalty)
    let chosenRank = legalRanks[0];

    if (state.mustPlayAny){
      // prefer dumping high-penalty cards early? Actually you want to avoid holding 10/Joker but already handled.
      // Choose the rank that reduces expected penalty: play high-penalty ranks first (K/Q/J=10 pts, 9..2 low-ish, A=1).
      chosenRank = legalRanks.slice().sort((a,b)=> penaltyPriority(b) - penaltyPriority(a))[0];
    } else {
      // choose closest to top (highest playValue within <= top)
      chosenRank = legalRanks.slice().sort((a,b)=> playValue(b) - playValue(a))[0];
      // but ensure it's <= top by canPlayOnTop already
    }

    const cards = byRank.get(chosenRank);
    // play as many as you have (shed)
    const toPlay = cards.slice(0, cards.length);
    const playList = toPlay.map(c => ({
      card: c,
      src: bot.hand.find(x=>x.id===c.id) ? {zone:"hand"} : {zone:"tableUp", stackIndex: bot.tableUp.findIndex(x=>x && x.id===c.id)}
    }));

    const res = playCards(bot, playList);
    if (endHandIfNeeded()) return;
    if (res.extraTurn) return botTakeTurn(bot);
    nextPlayer();
  }

  function penaltyPriority(rank){
    if (rank === "JOKER") return 100;
    if (rank === "10") return 60;
    if (rank === "K" || rank === "Q" || rank === "J") return 40;
    if (rank === "A") return 1;
    return parseInt(rank,10);
  }

  function advanceBotsIfNeeded(){
    // run bots until it's your turn or game/hand pause
    while (!state.gameOver && state.currentPlayer !== 0){
      const bot = state.players[state.currentPlayer];
      botTakeTurn(bot);
      // Stop if hand ended and waiting for "New Hand"
      if (state.gameOver) break;
      if (state.currentPlayer === 0) break;
      // If handIndex advanced but we haven't dealt: we pause for user action
      // We detect by pile/top? simpler: if log instructs "Click New Hand", we just stop
      // We'll stop if no pile and mustPlayAny and deck is fresh? Not needed.
      // We'll stop if a winner was detected (endHandIfNeeded would have logged and render).
      const winnerExists = state.players.some(p => playerRemaining(p) === 0);
      if (winnerExists) break;
    }
  }

  // ======= Human actions =======
  function humanPlay(){
    if (state.currentPlayer !== 0 || state.gameOver) return;

    const you = state.players[0];
    const playList = selectedCards();
    const v = validateSelection(playList);
    if (!v.ok){
      addLog(`‚ùå ${v.msg}`, "bad");
      return;
    }

    // If face-down: play it (discover)
    if (playList.length === 1 && playList[0].src.zone === "tableDown"){
      resetSelection();
      const res = playCards(you, playList);
      render();
      if (endHandIfNeeded()) return;
      if (res.extraTurn){
        // you go again
        render();
        return;
      }
      nextPlayer();
      advanceBotsIfNeeded();
      return;
    }

    // Known cards
    resetSelection();
    const res = playCards(you, playList);
    render();
    if (endHandIfNeeded()) return;
    if (res.extraTurn){
      // you play again (ANY)
      render();
      return;
    }
    nextPlayer();
    advanceBotsIfNeeded();
  }

  function humanPickup(){
    if (state.currentPlayer !== 0 || state.gameOver) return;
    const you = state.players[0];
    resetSelection();
    pickupPile(you);
    render();
    nextPlayer();
    advanceBotsIfNeeded();
  }

  function humanHint(){
    if (state.currentPlayer !== 0 || state.gameOver) return;
    const you = state.players[0];

    // If no hand/up, suggest a face-down stack
    const anyPlayableKnown = (you.hand.length + you.tableUp.filter(Boolean).length) > 0;
    if (!anyPlayableKnown){
      const candidates = you.tableDown.map((c,i)=>({c,i})).filter(x=>x.c && !you.tableUp[x.i]);
      if (candidates.length){
        addLog(`Hint: you must play a face-down card (choose any stack).`, "warn");
      } else {
        addLog(`Hint: you have no cards left (should have ended).`, "warn");
      }
      return;
    }

    const {ranks, byRank} = computeLegalPlays(you);
    if (ranks.length === 0){
      addLog(`Hint: no legal play from hand/face-up ‚Üí pick up the pile.`, "warn");
      return;
    }

    // Prefer triple clear if available
    for (const r of ranks){
      if (r==="10" || r==="JOKER") continue;
      const existing = countRankOnPile(r);
      const needed = Math.max(0, 3 - existing);
      const have = (byRank.get(r) || []).length;
      if (needed > 0 && have >= needed){
        addLog(`Hint: play ${needed}√ó${r} to complete a triple and clear.`, "ok");
        return;
      }
    }

    // Otherwise suggest highest legal under constraint
    if (ranks.includes("10") || ranks.includes("JOKER")){
      addLog(`Hint: a 10/Joker will clear the pile instantly (use if beneficial).`, "ok");
      return;
    }

    const best = ranks.slice().sort((a,b)=> playValue(b) - playValue(a))[0];
    addLog(`Hint: play ${best} (highest legal) to restrict others.`, "ok");
  }

  // ======= UI wiring =======
  el("newGame").onclick = () => {
    state.numPlayers = parseInt(el("numPlayers").value, 10);
    state.players = createPlayers(state.numPlayers);
    state.handIndex = 1;
    logEl.innerHTML = "";
    addLog(`New game started with ${state.numPlayers} players.`, "ok");
    dealHand();
    advanceBotsIfNeeded();
  };

  el("newHand").onclick = () => {
    if (state.gameOver){
      addLog(`Game is over. Click "New Game" to restart.`, "warn");
      return;
    }
    // Only allow new hand if we're between hands or starting fresh
    dealHand();
    advanceBotsIfNeeded();
  };

  el("playBtn").onclick = humanPlay;
  el("pickupBtn").onclick = humanPickup;
  el("hintBtn").onclick = humanHint;

  window.addEventListener("keydown", (e) => {
    if (e.key === "Enter") humanPlay();
    if (e.key.toLowerCase() === "p") humanPickup();
    if (e.key.toLowerCase() === "h") humanHint();
  });

  // Start default
  state.numPlayers = parseInt(el("numPlayers").value, 10);
  state.players = createPlayers(state.numPlayers);
  addLog(`Ready. Click "New Game" to begin.`, "ok");
  render();

})();
</script>
</body>
</html>
