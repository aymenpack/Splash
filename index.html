<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Splash Practice</title>

  <style>
    :root{
      --bg:#0b1220;
      --table1:#12204a;
      --table2:#0c1430;
      --panel:rgba(255,255,255,.04);
      --panelBorder:rgba(255,255,255,.10);
      --accent:#63b3ed;
      --danger:#ff7b72;
      --ok:#7ee787;
      --muted:rgba(230,237,247,.72);
      --shadow:0 10px 26px rgba(0,0,0,.45);

      --card-w:76px;
      --card-h:110px;
      --avatar:44px;
      --pile-h:150px;
      --gap:10px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      color:#e6edf7;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(circle at top, #142046, var(--bg) 60%);
      -webkit-tap-highlight-color: transparent;
    }

    header{
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    header h1{
      margin:0;
      font-size:15px;
      font-weight:900;
      letter-spacing:.2px;
    }

    select,button,input{
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.16);
      color:#e6edf7;
      padding:8px 12px;
      border-radius:12px;
      font-size:13px;
      outline:none;
    }

    button{ cursor:pointer; }
    button.primary{ background:rgba(99,179,237,.22); border-color:rgba(99,179,237,.45); }
    button.danger{ background:rgba(255,123,114,.18); border-color:rgba(255,123,114,.45); }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    main{
      max-width:1300px;
      margin:auto;
      padding:12px 12px calc(16px + env(safe-area-inset-bottom));
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 420px;
      gap:12px;
    }

    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .muted{ color:var(--muted); font-size:12px; }
    .small{ font-size:12px; }
    .pill{
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      font-size:12px;
      display:inline-flex;
      gap:6px;
      align-items:center;
      white-space:nowrap;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px;
      padding:2px 6px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
    }

    .table{
      background: linear-gradient(180deg, var(--table1), var(--table2));
      border-radius:20px;
      padding:12px;
      box-shadow: var(--shadow);
    }

    /* Seats */
    .playersRow{
      position:relative;
      height:180px;
      margin-bottom:10px;
    }

    .playerChip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:14px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      min-width:150px;
      position:absolute;
    }

    .playerChip.active{
      outline:2px solid var(--accent);
      box-shadow:0 0 16px rgba(99,179,237,.45);
      animation: seatPulse 1.6s ease-out infinite;
    }

    .playerChip.inactive{
      opacity: 0.55;
      filter: grayscale(.35);
    }

    .seat-bottom{ left:50%; bottom:0; transform:translateX(-50%); }
    .seat-top{ left:50%; top:0; transform:translateX(-50%); }
    .seat-left{ left:0; top:50%; transform:translateY(-50%); }
    .seat-right{ right:0; top:50%; transform:translateY(-50%); }
    .seat-tl{ left:0; top:0; transform:none; }
    .seat-tr{ right:0; top:0; transform:none; }

    @keyframes seatPulse {
      0%   { box-shadow: 0 0 0 0 rgba(99,179,237,.55); }
      70%  { box-shadow: 0 0 0 14px rgba(99,179,237,0); }
      100% { box-shadow: 0 0 0 0 rgba(99,179,237,0); }
    }

    .avatar{
      width:var(--avatar);
      height:var(--avatar);
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      color:#0b1220;
      position:relative;
    }

    .avatar .emo{ font-size:20px; }
    .avatar .init{
      position:absolute;
      bottom:-2px; right:-2px;
      font-size:10px;
      padding:1px 5px;
      border-radius:999px;
      background:#000;
      color:#fff;
    }

    /* Mobile: fall back */
    @media (max-width: 700px){
      .playersRow{
        position:static;
        height:auto;
        display:flex;
        justify-content:space-between;
        gap:8px;
        flex-wrap:wrap;
        margin-bottom:10px;
      }
      .playerChip{
        position:static;
        transform:none !important;
      }
    }

    .c{
      width:var(--card-w);
      height:var(--card-h);
      border-radius:12px;
      background:#fff;
      color:#111;
      position:relative;
      box-shadow:0 6px 18px rgba(0,0,0,.45);
      transition:.12s ease;
    }

    .c.selectable:hover{ transform:translateY(-4px); }
    .c.selected{ outline:3px solid var(--accent); transform:translateY(-6px); }

    .c.selectable.legal{
      box-shadow:
        0 0 0 2px rgba(99,179,237,.35),
        0 10px 22px rgba(99,179,237,.25);
    }

    .c.illegal{
      opacity:0.45;
      filter: grayscale(1) blur(.3px);
      cursor:not-allowed;
    }

    @keyframes illegalShake {
      0%{ transform:translateX(0); }
      25%{ transform:translateX(-6px); }
      50%{ transform:translateX(6px); }
      75%{ transform:translateX(-4px); }
      100%{ transform:translateX(0); }
    }
    .c.illegal.shake{
      animation: illegalShake .25s ease-in-out;
    }

    .corner{
      position:absolute;
      font-weight:900;
      font-size:13px;
      line-height:1;
    }
    .corner.top{ top:6px; left:6px; }
    .corner.bottom{ bottom:6px; right:6px; transform:rotate(180deg); }

    .pip{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      font-size:32px;
    }

    .subpip{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      font-size:12px;
      opacity:.75;
      margin-top:30px;
      letter-spacing:.6px;
      font-weight:800;
    }

    .c.back{
      background:linear-gradient(135deg,#1b2a55,#0b1220);
      border:2px dashed rgba(255,255,255,.45);
    }

    .zoneTitle{
      margin:10px 0 6px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
    }

    .hand{ display:flex; gap:var(--gap); flex-wrap:wrap; }
    .handScroll{
      display:flex;
      gap:var(--gap);
      overflow-x:auto;
      padding-bottom:4px;
    }

    .note{
      margin-top:10px;
      padding:10px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .pileRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    .pileVisualWrap{
      width:100%;
      height:var(--pile-h);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
      margin-top:8px;
      position:relative;
      overflow:hidden;
    }

    .pileCard{
      position:absolute;
      left: calc(50% - 38px);
      top: 20px;
      will-change: transform, opacity;
    }

    @keyframes popIn {
      0%{ transform: translateY(18px) scale(.92); opacity:0; }
      100%{ transform: translateY(0) scale(1); opacity:1; }
    }
    .anim-pop{ animation: popIn .18s ease-out; }

    @keyframes clearBurst {
      0%{ box-shadow: 0 0 0 rgba(99,179,237,0); }
      30%{ box-shadow: 0 0 30px rgba(99,179,237,.55); }
      100%{ box-shadow: 0 0 0 rgba(99,179,237,0); }
    }
    .burst{ animation: clearBurst .35s ease-out; }

    .flyLayer{
      position: fixed;
      inset: 0;
      pointer-events:none;
      z-index: 9999;
    }
    .flyCard{
      position: fixed;
      width: 56px;
      height: 78px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.18);
      background: #fff;
      box-shadow: 0 14px 30px rgba(0,0,0,.55);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      opacity: 0.95;
      transform: translate(0,0) scale(1);
      transition: transform .45s ease, opacity .45s ease;
      color:#111;
    }

    .panel{
      background:rgba(255,255,255,.04);
      border-radius:18px;
      padding:12px;
    }

    .log{
      background:rgba(0,0,0,.35);
      border-radius:14px;
      padding:8px;
      font-family:ui-monospace,monospace;
      font-size:12px;
      max-height:300px;
      overflow:auto;
    }

    .log .line{ padding:2px 0; border-bottom:1px dashed rgba(255,255,255,.07); }
    .log .line:last-child{ border-bottom:none; }

    .ok{ color:var(--ok); }
    .warn{ color:#f2cc60; }
    .bad{ color:var(--danger); }

    @media (max-width: 900px){
      :root{
        --card-w:68px;
        --card-h:100px;
        --avatar:40px;
        --pile-h:130px;
        --gap:8px;
      }
      .grid{ grid-template-columns:1fr; }
    }

    @media (max-width: 480px){
      :root{
        --card-w:60px;
        --card-h:88px;
        --avatar:36px;
        --pile-h:110px;
        --gap:6px;
      }
      header h1{ font-size:14px; }
      select,button,input{ font-size:12px; padding:7px 10px; }
      .log{ max-height:200px; font-size:11px; }
      .corner{ font-size:11px; }
      .pip{ font-size:26px; }
    }

    /* Multiplayer bar in header */
    .mpbar{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
      margin-left:auto;
    }
    .mpbar input{ width:90px; }
    .mpbar #mpRoom{ text-transform:uppercase; width:90px; }
    .mpStatus{ font-size:12px; opacity:.7; }

  </style>
</head>

<body>
<header>
  <h1>üÉè Splash Practice</h1>

  <!-- Multiplayer controls -->
  <div class="mpbar">
    <input id="mpName" placeholder="Name" />
    <input id="mpRoom" placeholder="ROOM" />
    <button id="hostBtn" class="primary">Host</button>
    <button id="joinBtn" class="primary">Join</button>
    <span id="mpStatus" class="mpStatus"></span>
  </div>

  <div class="controls">
    <label class="muted">Players</label>
    <select id="numPlayers">
      <option>3</option><option selected>4</option><option>5</option><option>6</option>
    </select>
    <button id="newGame" class="primary">New Game</button>
    <button id="newHand">New Hand</button>
    <span class="pill" id="handInfo">Hand 1 / 5</span>
    <span class="pill" id="turnInfo">Turn: ‚Äî</span>
  </div>
</header>

<div class="flyLayer" id="flyLayer"></div>

<main>
  <div class="grid">

    <section class="table">
      <div class="playersRow" id="playersRow"></div>

      <div class="note">
        <div class="pileRow">
          <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
            <span class="pill">Draw: <span id="drawCount">‚Äî</span></span>
            <span class="pill" id="discardPill">Discard: <span id="discardCount">‚Äî</span></span>
            <span class="pill">Pile: <span id="pileCount">‚Äî</span></span>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <span class="muted">Top:</span>
            <span class="pill" id="topValue">‚Äî</span>
          </div>
        </div>

        <div class="pileVisualWrap" id="pileVisualWrap"></div>

        <div class="muted" style="margin-top:10px;">
          Online mode: each player sees their own hand only. (Server-authoritative rules next.)
        </div>
      </div>

      <div class="zoneTitle">
        <span id="handLabel">Your hand</span>
        <span class="muted" id="turnHint"></span>
      </div>
      <div id="yourHand" class="handScroll"></div>

      <div class="zoneTitle">
        <span id="tableLabel">Your table</span>
      </div>
      <div id="yourTable" class="hand"></div>
    </section>

    <section class="panel">
      <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <button id="playBtn" class="primary">Play Selected</button>
        <button id="pickupBtn" class="danger">Pick Up Pile</button>
        <button id="hintBtn">Hint</button>
      </div>

      <div class="zoneTitle" style="margin-top:12px;">
        <span>Log</span>
      </div>
      <div id="log" class="log"></div>
    </section>

  </div>
</main>

<script>
(() => {

  /* =========================================================
     ONLINE MULTIPLAYER (no observers)
     ========================================================= */
  const WS_BASE = "wss://splash-multiplayer.azimaymen.workers.dev";

  let mpWs = null;
  let mpRoom = null;
  const mpClientId = crypto.randomUUID();
  let isMultiplayer = false;
  let myPlayerIndex = null; // 0..N-1 seat in room order

  function mpSetStatus(t){
    const s = document.getElementById("mpStatus");
    if (s) s.textContent = t;
  }

  function mpConnect(room){
    isMultiplayer = true;
    mpRoom = room.toUpperCase();
    mpWs = new WebSocket(`${WS_BASE}?room=${mpRoom}`);

    mpWs.onopen = () => {
      mpSetStatus(`Connected ${mpRoom}`);
      mpWs.send(JSON.stringify({
        type:"join",
        id: mpClientId,
        name: document.getElementById("mpName").value || "Player"
      }));
    };

    mpWs.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "players"){
        // Seat assignment based on join order
        const idx = msg.players.findIndex(p => p.id === mpClientId);
        if (idx !== -1) myPlayerIndex = idx;

        // If we haven't started a game yet, map names into state.players
        // (Host will still press New Game to start)
        if (state.players.length !== msg.players.length){
          state.numPlayers = msg.players.length;
          state.players = createPlayers(state.numPlayers);
        }
        msg.players.forEach((p, i) => {
          if (state.players[i]){
            state.players[i].name = p.name;
            state.players[i].initials = initialsFromName(p.name);
          }
        });

        render();
      }

      if (msg.type === "state"){
        applyRemoteState(msg.payload);
      }
    };

    mpWs.onclose = () => mpSetStatus("Disconnected");
    mpWs.onerror = () => mpSetStatus("Error");
  }

  function mpBroadcast(payload){
    if (!mpWs || mpWs.readyState !== WebSocket.OPEN) return;
    mpWs.send(JSON.stringify({ type:"broadcast", payload }));
  }

  document.getElementById("hostBtn").onclick = () => {
    const code = Math.random().toString(36).slice(2,8).toUpperCase();
    document.getElementById("mpRoom").value = code;
    mpConnect(code);
    alert("Room code: " + code);
  };

  document.getElementById("joinBtn").onclick = () => {
    const code = document.getElementById("mpRoom").value.trim();
    if (!code) return alert("Enter room code");
    mpConnect(code);
  };

  function serializeGameState(){
    return JSON.parse(JSON.stringify(state));
  }

  function applyRemoteState(remote){
    // Update data only, keep local references stable
    state.numPlayers    = remote.numPlayers;
    state.players       = remote.players;
    state.deck          = remote.deck;
    state.discard       = remote.discard;
    state.pile          = remote.pile;
    state.pileTopRank   = remote.pileTopRank;
    state.handIndex     = remote.handIndex;
    state.handsTotal    = remote.handsTotal;
    state.currentPlayer = remote.currentPlayer;
    state.mustPlayAny   = remote.mustPlayAny;
    state.gameOver      = remote.gameOver;

    render();
  }

  /* =========================================================
     ORIGINAL GAME CODE (kept)
     ========================================================= */

  const SUITS = ["‚ô†","‚ô•","‚ô¶","‚ô£"];
  const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const RANK_ORDER = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const rankOrder = (rank) => RANK_ORDER.indexOf(rank);

  const EMOJIS = ["ü¶ä","üêº","üêØ","ü¶Å","üê∏","üêô","ü¶â","ü¶Ñ","üê≤","üê∂","üê±","üêµ"];

  const SEAT_COLORS = [
    ["#63b3ed","#7ee787"],
    ["#f2cc60","#ff7b72"],
    ["#a78bfa","#63b3ed"],
    ["#34d399","#f2cc60"],
    ["#fb7185","#a78bfa"],
    ["#60a5fa","#fb7185"],
  ];

  const SEAT_CLASSES = ["seat-bottom","seat-left","seat-top","seat-right","seat-tl","seat-tr"];

  const isJoker = c => c.rank === "JOKER";
  const isTenOrJoker = c => c.rank === "10" || isJoker(c);

  const PlayerType = { HUMAN:"HUMAN", BOT:"BOT", REMOTE:"REMOTE" };

  const scoreValue = (card) => {
    if (isJoker(card)) return 50;
    if (card.rank === "10") return 20;
    if (card.rank === "A") return 1;
    if (card.rank === "J" || card.rank === "Q" || card.rank === "K") return 10;
    return parseInt(card.rank, 10);
  };

  const state = {
    numPlayers: 4,
    players: [],
    deck: [],
    discard: [],
    pile: [],
    pileTopRank: null,
    handIndex: 1,
    handsTotal: 5,
    currentPlayer: 0,
    mustPlayAny: false,
    gameOver: false,

    // local-only pass-and-play fields (unused in multiplayer)
    viewPlayer: null,
    revealedThisTurn: true,
    peekOnly: false
  };

  const el = (id) => document.getElementById(id);
  const logEl = el("log");
  const yourHandEl = el("yourHand");
  const yourTableEl = el("yourTable");
  const playersRowEl = el("playersRow");
  const pileVisualWrap = el("pileVisualWrap");

  let selected = new Set();
  let selectedSources = new Map();
  let uid = 0;
  const newId = () => (++uid).toString();

  let lastTap = { id: null, t: 0 };

  function toneDot(tone){
    if (tone==="ok") return `<span class="ok">‚óè</span> `;
    if (tone==="warn") return `<span class="warn">‚óè</span> `;
    if (tone==="bad") return `<span class="bad">‚óè</span> `;
    return "";
  }
  function addLog(text, tone=""){
    const div = document.createElement("div");
    div.className = "line";
    div.innerHTML = `${toneDot(tone)}${text}`;
    logEl.prepend(div);
  }

  function initialsFromName(name){
    const parts = name.trim().split(/\s+/).filter(Boolean);
    if (parts.length === 0) return "P";
    if (parts.length === 1) return parts[0].slice(0,2).toUpperCase();
    return (parts[0][0] + parts[parts.length-1][0]).toUpperCase();
  }

  function seatGradient(i){
    const [a,b] = SEAT_COLORS[i % SEAT_COLORS.length];
    return `linear-gradient(135deg, ${a}, ${b})`;
  }

  function createPlayers(n){
    return Array.from({length:n}, (_,i)=>({
      id:i,
      type: PlayerType.HUMAN,
      name: `Player ${i+1}`,
      emoji: EMOJIS[i % EMOJIS.length],
      initials: `P${i+1}`,
      hand: [],
      tableUp: Array.from({length:4}, ()=>null),
      tableDown: Array.from({length:4}, ()=>null),
      score: 0
    }));
  }

  function resetSelection(){
    selected.clear();
    selectedSources.clear();
  }

  function topRank(){
    const top = state.pile[state.pile.length-1];
    return top ? top.rank : state.pileTopRank;
  }

  function canPlayOnTop(rank){
    if (state.mustPlayAny) return true;

    const top = topRank();
    if (!top) return true;

    if (rank === "10" || rank === "JOKER") return true;
    if (top === "10" || top === "JOKER") return false;

    const isFace = r => r === "J" || r === "Q" || r === "K";
    if (isFace(rank) && !isFace(top)) return false;

    return rankOrder(rank) <= rankOrder(top);
  }

  function makeDeck(){
    const deck = [];
    for (let d=0; d<2; d++){
      for (const s of SUITS){
        for (const r of RANKS){
          deck.push({ id:newId(), rank:r, suit:s });
        }
      }
    }
    for (let j=0; j<4; j++){
      deck.push({ id:newId(), rank:"JOKER", suit:"‚òÖ" });
    }
    for (let i=deck.length-1;i>0;i--){
      const k = Math.floor(Math.random()*(i+1));
      [deck[i], deck[k]] = [deck[k], deck[i]];
    }
    return deck;
  }

  function dealHand(){
    resetSelection();
    state.deck = makeDeck();
    state.discard = [];
    state.pile = [];
    state.mustPlayAny = false;
    state.gameOver = false;

    for (const p of state.players){
      p.hand = [];
      p.tableUp = Array.from({length:4}, ()=>null);
      p.tableDown = Array.from({length:4}, ()=>null);
    }

    for (let i=0;i<4;i++){
      for (const p of state.players){
        p.tableDown[i] = state.deck.pop();
      }
    }
    for (let i=0;i<4;i++){
      for (const p of state.players){
        p.tableUp[i] = state.deck.pop();
      }
    }
    for (let i=0;i<11;i++){
      for (const p of state.players){
        p.hand.push(state.deck.pop());
      }
    }

    // start card
    const c = state.deck.pop();
    state.pile.push(c);
    state.pileTopRank = c.rank;

    if (c.rank === "10" || c.rank === "JOKER"){
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
    } else {
      state.mustPlayAny = false;
    }

    state.currentPlayer = 0;
    addLog(`New game started (online players).`, "ok");
    render();

    // broadcast
    mpBroadcast(serializeGameState());
  }

  function makeCardDiv(card){
    const div = document.createElement("div");
    div.className = "c";
    if (card.rank === "JOKER"){
      div.innerHTML = `<div class="corner top">JOKER<br>‚òÖ</div><div class="pip">‚òÖ</div><div class="corner bottom">JOKER<br>‚òÖ</div>`;
      return div;
    }
    div.innerHTML = `
      <div class="corner top">${card.rank}<br>${card.suit}</div>
      <div class="pip">${card.suit}</div>
      <div class="corner bottom">${card.rank}<br>${card.suit}</div>
    `;
    return div;
  }

  function renderPile(){
    pileVisualWrap.innerHTML = "";
    state.pile.slice(-6).forEach((c,i)=>{
      const d = makeCardDiv(c);
      d.classList.add("pileCard");
      const rot = (Math.random()*2-1);
      d.style.transform = `translate(${i*12}px, ${i*4}px) rotate(${rot}deg)`;
      pileVisualWrap.appendChild(d);
    });
  }

  function renderPlayers(){
    playersRowEl.innerHTML = "";
    state.players.forEach((p, idx)=>{
      const chip = document.createElement("div");
      const seat = SEAT_CLASSES[idx] || "";
      chip.className = `playerChip ${seat} ${idx===state.currentPlayer ? "active" : "inactive"}`;
      chip.innerHTML = `
        <div class="avatar" style="background:${seatGradient(idx)}">
          <div class="emo">${p.emoji}</div>
          <div class="init">${p.initials}</div>
        </div>
        <div>
          <div style="font-weight:900">${p.name}</div>
          <div class="muted" style="font-size:11px">H ${p.hand.length}</div>
        </div>
      `;
      playersRowEl.appendChild(chip);
    });
  }

  function renderMyHand(){
    yourHandEl.innerHTML = "";
    yourTableEl.innerHTML = "";

    if (myPlayerIndex === null){
      return;
    }

    const me = state.players[myPlayerIndex];
    if (!me) return;

    // hand
    me.hand.forEach(card=>{
      const d = makeCardDiv(card);
      d.classList.add("selectable");

      const legal = canPlayOnTop(card.rank);
      if (legal) d.classList.add("legal"); else d.classList.add("illegal");
      if (selected.has(card.id)) d.classList.add("selected");

      d.onclick = () => {
        if (!isTurnPlayable()) return;
        if (!legal){
          d.classList.remove("shake"); void d.offsetWidth; d.classList.add("shake");
          addLog("‚ùå Illegal", "bad");
          return;
        }
        // select
        if (selected.has(card.id)) selected.delete(card.id);
        else {
          // only same rank selection
          if (selected.size){
            const anyId = selected.values().next().value;
            const anyCard = me.hand.find(x=>x.id===anyId) || null;
            if (anyCard && anyCard.rank !== card.rank){
              selected.clear();
            }
          }
          selected.add(card.id);
        }
        render();
      };

      yourHandEl.appendChild(d);
    });

    // tableUp/Down
    for (let i=0;i<4;i++){
      const up = me.tableUp[i];
      const down = me.tableDown[i];

      if (up){
        const d = makeCardDiv(up);
        d.classList.add("selectable");
        const legal = canPlayOnTop(up.rank);
        if (legal) d.classList.add("legal"); else d.classList.add("illegal");
        if (selected.has(up.id)) d.classList.add("selected");

        d.onclick = () => {
          if (!isTurnPlayable()) return;
          if (!legal){
            d.classList.remove("shake"); void d.offsetWidth; d.classList.add("shake");
            addLog("‚ùå Illegal", "bad");
            return;
          }
          if (selected.has(up.id)) selected.delete(up.id);
          else {
            if (selected.size){
              // ensure same rank selection
              const anyId = selected.values().next().value;
              const anyHand = me.hand.find(x=>x.id===anyId);
              const anyUp = me.tableUp.find(x=>x && x.id===anyId);
              const anyCard = anyHand || anyUp;
              if (anyCard && anyCard.rank !== up.rank){
                selected.clear();
              }
            }
            selected.add(up.id);
          }
          render();
        };

        yourTableEl.appendChild(d);
      } else if (down){
        const d = document.createElement("div");
        d.className = "c back selectable";
        d.innerHTML = `<div class="pip" style="color:rgba(255,255,255,.9)">üÇ†</div>`;
        d.onclick = () => {
          if (!isTurnPlayable()) return;
          // face-down alone
          selected.clear();
          selected.add(down.id);
          // mark where it is
          selectedSources.clear();
          selectedSources.set(down.id, {zone:"tableDown", stackIndex:i});
          render();
        };
        yourTableEl.appendChild(d);
      } else {
        const empty = document.createElement("div");
        empty.className = "c";
        empty.style.opacity = "0.2";
        empty.innerHTML = `<div class="pip">‚Äî</div>`;
        yourTableEl.appendChild(empty);
      }
    }
  }

  function isTurnPlayable(){
    if (!isMultiplayer) return true;
    if (myPlayerIndex === null) return false;
    return myPlayerIndex === state.currentPlayer;
  }

  function applySelectedPlay(){
    if (!isTurnPlayable()) return;
    if (myPlayerIndex === null) return;
    const me = state.players[myPlayerIndex];
    if (!me) return;

    // face-down?
    if (selected.size === 1){
      const only = selected.values().next().value;
      const downIdx = me.tableDown.findIndex(x=>x && x.id===only);
      if (downIdx !== -1){
        // play face-down
        const card = me.tableDown[downIdx];
        me.tableDown[downIdx] = null;

        const top = topRank();
        if (!canPlayOnTop(card.rank)){
          // illegal: pick up pile + played card
          state.pile.push(card);
          me.hand.push(...state.pile);
          state.pile = [];
          state.mustPlayAny = true;
          selected.clear();
          state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
          mpBroadcast(serializeGameState());
          render();
          return;
        }

        state.pile.push(card);

        if (card.rank === "10" || card.rank === "JOKER"){
          state.discard.push(...state.pile);
          state.pile = [];
          state.mustPlayAny = true;
          selected.clear();
          mpBroadcast(serializeGameState());
          render();
          return; // extra turn
        }

        // triple
        const r = card.rank;
        const cnt = state.pile.reduce((a,x)=>a+(x.rank===r?1:0),0);
        if (cnt >= 3){
          state.discard.push(...state.pile);
          state.pile = [];
          state.mustPlayAny = true;
          selected.clear();
          mpBroadcast(serializeGameState());
          render();
          return; // extra turn
        }

        state.mustPlayAny = false;
        selected.clear();
        state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
        mpBroadcast(serializeGameState());
        render();
        return;
      }
    }

    // normal play: all selected must be same rank
    const ids = Array.from(selected);
    const allCards = [];
    for (const id of ids){
      const h = me.hand.find(x=>x.id===id);
      if (h) allCards.push({card:h, zone:"hand"});
      const upIdx = me.tableUp.findIndex(x=>x && x.id===id);
      if (upIdx !== -1) allCards.push({card:me.tableUp[upIdx], zone:"tableUp", stackIndex:upIdx});
    }
    if (!allCards.length) return;

    const rank = allCards[0].card.rank;
    if (!allCards.every(x=>x.card.rank===rank)) {
      addLog("‚ùå Must play same rank", "bad");
      return;
    }
    if (!canPlayOnTop(rank)){
      addLog("‚ùå Illegal", "bad");
      return;
    }

    // remove from zones
    for (const x of allCards){
      if (x.zone==="hand"){
        me.hand = me.hand.filter(c=>c.id!==x.card.id);
      } else if (x.zone==="tableUp"){
        me.tableUp[x.stackIndex] = null;
      }
      state.pile.push(x.card);
    }

    // clears
    if (rank==="10" || rank==="JOKER"){
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
      selected.clear();
      mpBroadcast(serializeGameState());
      render();
      return; // extra turn
    }

    // triple
    const cnt = state.pile.reduce((a,x)=>a+(x.rank===rank?1:0),0);
    if (cnt >= 3){
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
      selected.clear();
      mpBroadcast(serializeGameState());
      render();
      return; // extra turn
    }

    state.mustPlayAny = false;
    selected.clear();
    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
    mpBroadcast(serializeGameState());
    render();
  }

  function pickup(){
    if (!isTurnPlayable()) return;
    if (myPlayerIndex === null) return;
    const me = state.players[myPlayerIndex];
    if (!me) return;

    me.hand.push(...state.pile);
    state.pile = [];
    state.mustPlayAny = true;
    selected.clear();
    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
    mpBroadcast(serializeGameState());
    render();
  }

  function render(){
    // update counters
    document.getElementById("drawCount").textContent = String(state.deck.length);
    document.getElementById("discardCount").textContent = String(state.discard.length);
    document.getElementById("pileCount").textContent = String(state.pile.length);
    document.getElementById("topValue").textContent = state.mustPlayAny ? "ANY" : (topRank() || "‚Äî");
    document.getElementById("turnInfo").textContent = state.players[state.currentPlayer]?.name || "‚Äî";

    const hint = document.getElementById("turnHint");
    if (hint){
      hint.textContent = isTurnPlayable() ? "Your turn" : "Waiting‚Ä¶";
    }

    renderPlayers();
    renderPile();
    renderMyHand();

    document.getElementById("playBtn").disabled = !isTurnPlayable();
    document.getElementById("pickupBtn").disabled = !isTurnPlayable();
    document.getElementById("hintBtn").disabled = !isTurnPlayable();
    document.getElementById("newGame").disabled = isMultiplayer && myPlayerIndex !== 0; // only player 0 starts
  }

  // Buttons
  document.getElementById("newGame").onclick = () => {
    if (isMultiplayer && myPlayerIndex !== 0){
      alert("Only Player 1 (seat 1) can start the game.");
      return;
    }
    state.numPlayers = state.players.length || parseInt(document.getElementById("numPlayers").value,10);
    if (!state.players.length) state.players = createPlayers(state.numPlayers);
    dealHand();
  };

  document.getElementById("newHand").onclick = () => {
    if (isMultiplayer && myPlayerIndex !== 0){
      alert("Only Player 1 can start a new hand.");
      return;
    }
    dealHand();
  };

  document.getElementById("playBtn").onclick = applySelectedPlay;
  document.getElementById("pickupBtn").onclick = pickup;

  // init local state
  state.numPlayers = parseInt(document.getElementById("numPlayers").value,10);
  state.players = createPlayers(state.numPlayers);
  state.players.forEach((p,i)=> p.initials = initialsFromName(p.name) || `P${i+1}`);
  addLog("Ready. Host a room or join one. Player 1 starts New Game.", "ok");
  render();

})();
</script>
</body>
</html>
