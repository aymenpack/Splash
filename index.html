<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Splash Practice</title>

  <style>
    /* =========================================================
       ROOT VARIABLES (DESKTOP DEFAULTS)
       ========================================================= */
    :root{
      --bg:#0b1220;
      --table1:#12204a;
      --table2:#0c1430;
      --panel:rgba(255,255,255,.04);
      --panelBorder:rgba(255,255,255,.10);
      --accent:#63b3ed;
      --danger:#ff7b72;
      --ok:#7ee787;
      --muted:rgba(230,237,247,.72);
      --shadow:0 10px 26px rgba(0,0,0,.45);

      /* Sizing */
      --card-w:76px;
      --card-h:110px;
      --avatar:44px;
      --pile-h:150px;
      --gap:10px;
    }

    /* =========================================================
       GLOBAL
       ========================================================= */
    *{ box-sizing:border-box; }

    body{
      margin:0;
      color:#e6edf7;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(circle at top, #142046, var(--bg) 60%);
      -webkit-tap-highlight-color: transparent;
    }

    header{
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    header h1{
      margin:0;
      font-size:15px;
      font-weight:900;
      letter-spacing:.2px;
    }

    select,button,input{
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.16);
      color:#e6edf7;
      padding:8px 12px;
      border-radius:12px;
      font-size:13px;
    }

    button.primary{ background:rgba(99,179,237,.22); border-color:rgba(99,179,237,.45); }
    button.danger{ background:rgba(255,123,114,.18); border-color:rgba(255,123,114,.45); }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    main{
      max-width:1300px;
      margin:auto;
      padding:12px 12px calc(16px + env(safe-area-inset-bottom));
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 420px;
      gap:12px;
    }

    /* =========================================================
       TABLE + PLAYERS
       ========================================================= */
    .table{
      background: linear-gradient(180deg, var(--table1), var(--table2));
      border-radius:20px;
      padding:12px;
      box-shadow: var(--shadow);
    }

    /* ‚úÖ Seat layout container (desktop/tablet) */
    .playersRow{
      position:relative;
      height:180px;
      margin-bottom:10px;
    }

    .playerChip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:14px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      min-width:150px;
      position:absolute;          /* ‚úÖ seat positioning */
    }

    .playerChip.active{
      outline:2px solid var(--accent);
      box-shadow:0 0 16px rgba(99,179,237,.45);
    }

    .avatar{
      width:var(--avatar);
      height:var(--avatar);
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      color:#0b1220;
      position:relative;
    }

    .avatar .emo{ font-size:20px; }
    .avatar .init{
      position:absolute;
      bottom:-2px; right:-2px;
      font-size:10px;
      padding:1px 5px;
      border-radius:999px;
      background:#000;
      color:#fff;
    }

    /* ‚úÖ Seat positions */
    .seat-bottom{ left:50%; bottom:0; transform:translateX(-50%); }
    .seat-top{ left:50%; top:0; transform:translateX(-50%); }
    .seat-left{ left:0; top:50%; transform:translateY(-50%); }
    .seat-right{ right:0; top:50%; transform:translateY(-50%); }
    .seat-tl{ left:0; top:0; }
    .seat-tr{ right:0; top:0; }

    /* =========================================================
       CARDS
       ========================================================= */
    .c{
      width:var(--card-w);
      height:var(--card-h);
      border-radius:12px;
      background:#fff;
      color:#111;
      position:relative;
      box-shadow:0 6px 18px rgba(0,0,0,.45);
      transition:.12s ease;
    }

    .c.selectable:hover{ transform:translateY(-4px); }
    .c.selected{ outline:3px solid var(--accent); transform:translateY(-6px); }

    .corner{
      position:absolute;
      font-weight:900;
      font-size:13px;
      line-height:1;
    }
    .corner.top{ top:6px; left:6px; }
    .corner.bottom{ bottom:6px; right:6px; transform:rotate(180deg); }

    .pip{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      font-size:32px;
    }

    .c.back{
      background:linear-gradient(135deg,#1b2a55,#0b1220);
      border:2px dashed rgba(255,255,255,.45);
    }

    /* =========================================================
       ZONES
       ========================================================= */
    .zoneTitle{
      margin:10px 0 6px;
      font-size:12px;
      color:var(--muted);
    }

    .hand{ display:flex; gap:var(--gap); flex-wrap:wrap; }
    .handScroll{
      display:flex;
      gap:var(--gap);
      overflow-x:auto;
      padding-bottom:4px;
    }

    /* =========================================================
       PILE
       ========================================================= */
    .pileVisualWrap{
      width:100%;
      height:var(--pile-h);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
      margin-top:8px;
      position:relative;
    }

    /* =========================================================
       SIDE PANEL
       ========================================================= */
    .panel{
      background:rgba(255,255,255,.04);
      border-radius:18px;
      padding:12px;
    }

    .log{
      background:rgba(0,0,0,.35);
      border-radius:14px;
      padding:8px;
      font-family:ui-monospace,monospace;
      font-size:12px;
      max-height:300px;
      overflow:auto;
    }

    /* =========================================================
       RESPONSIVE BREAKPOINTS
       ========================================================= */

    /* ---------- iPad ---------- */
    @media (max-width: 900px){
      :root{
        --card-w:68px;
        --card-h:100px;
        --avatar:40px;
        --pile-h:130px;
        --gap:8px;
      }
      .grid{ grid-template-columns:1fr; }
      .playersRow{ height:210px; } /* a bit more room on tablet */
    }

    /* ‚úÖ On small screens, revert to the old flex row to avoid overlap */
    @media (max-width: 700px){
      .playersRow{
        position:static;
        height:auto;
        display:flex;
        justify-content:space-between;
        gap:8px;
        flex-wrap:wrap;
        margin-bottom:10px;
      }
      .playerChip{
        position:static;
        transform:none !important;
      }
    }

    /* ---------- iPhone ---------- */
    @media (max-width: 480px){
      :root{
        --card-w:60px;
        --card-h:88px;
        --avatar:36px;
        --pile-h:110px;
        --gap:6px;
      }

      header h1{ font-size:14px; }
      select,button{ font-size:12px; padding:7px 10px; }
      .log{ max-height:200px; font-size:11px; }
      .corner{ font-size:11px; }
      .pip{ font-size:26px; }
    }

    /* --- Your existing styles below (unchanged) --- */

    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .muted{ color:var(--muted); font-size:12px; }
    .small{ font-size:12px; }
    .pill{
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      font-size:12px;
      display:inline-flex;
      gap:6px;
      align-items:center;
      white-space:nowrap;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px;
      padding:2px 6px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
    }

    .note{
      margin-top:10px;
      padding:10px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .pileRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .pileCard{
      position:absolute;
      left: calc(50% - 38px);
      top: 20px;
      will-change: transform, opacity;
    }

    @keyframes popIn {
      0%{ transform: translateY(18px) scale(.92); opacity:0; }
      100%{ transform: translateY(0) scale(1); opacity:1; }
    }
    .anim-pop{ animation: popIn .18s ease-out; }
    @keyframes pileShake {
      0%{ transform: translateX(0); }
      20%{ transform: translateX(-6px); }
      40%{ transform: translateX(6px); }
      60%{ transform: translateX(-4px); }
      80%{ transform: translateX(4px); }
      100%{ transform: translateX(0); }
    }
    .shake{ animation: pileShake .22s ease-in-out; }
    @keyframes clearBurst {
      0%{ box-shadow: 0 0 0 rgba(99,179,237,0); }
      30%{ box-shadow: 0 0 30px rgba(99,179,237,.55); }
      100%{ box-shadow: 0 0 0 rgba(99,179,237,0); }
    }
    .burst{ animation: clearBurst .35s ease-out; }

    .flyLayer{
      position: fixed;
      inset: 0;
      pointer-events:none;
      z-index: 9999;
    }
    .flyCard{
      position: fixed;
      width: 56px;
      height: 78px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.18);
      background: #fff;
      box-shadow: 0 14px 30px rgba(0,0,0,.55);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      opacity: 0.95;
      transform: translate(0,0) scale(1);
      transition: transform .45s ease, opacity .45s ease;
      color:#111;
    }

    .ok{ color:var(--ok); }
    .warn{ color:#f2cc60; }
    .bad{ color:var(--danger); }

    .bottomBar{ display:none; }
    @media(max-width:700px){
      .bottomBar{
        display:flex;
        position:fixed;
        left:0; right:0; bottom:0;
        padding:10px 12px calc(10px + env(safe-area-inset-bottom));
        gap:10px;
        background: rgba(8,12,22,.88);
        border-top:1px solid rgba(255,255,255,.10);
        backdrop-filter: blur(10px);
        z-index: 1000;
      }
      .bottomBar button{
        flex:1;
        font-size:15px;
        padding:14px 14px;
        border-radius:16px;
      }
      main{ padding-bottom: 96px; }
      .topActions{ display:none !important; }
    }

    .overlay{
      position:fixed;
      inset:0;
      background: rgba(5,8,14,.86);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 2000;
      padding: 18px;
    }
    .overlay.show{ display:flex; }

    .overlayCard{
      width:min(520px, 100%);
      border-radius:24px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      box-shadow: 0 22px 60px rgba(0,0,0,.6);
      padding:18px;
      text-align:center;
    }
    .overlayCard h2{
      margin:0 0 8px;
      font-size:18px;
      font-weight:900;
    }
    .overlayCard .sub{ color:var(--muted); font-size:13px; margin-bottom:14px; }
    .overlayCard .bigAvatar{
      width:84px; height:84px;
      border-radius:50%;
      margin: 0 auto 14px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:34px;
      font-weight:900;
      color:#0b1220;
      position:relative;
      overflow:hidden;
    }
    .overlayCard .bigAvatar .init{
      position:absolute;
      bottom:4px; right:6px;
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      background: rgba(0,0,0,.75);
      color:#fff;
      border:1px solid rgba(255,255,255,.18);
      letter-spacing:.2px;
    }
    .overlayActions{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .overlayActions button{
      min-width: 160px;
      padding: 12px 16px;
      font-size: 14px;
      border-radius: 16px;
    }
  </style>
</head>

<body>
<header>
  <h1>üÉè Splash Practice</h1>
  <div class="controls">
    <label class="muted">Players</label>
    <select id="numPlayers">
      <option>3</option><option selected>4</option><option>5</option><option>6</option>
    </select>
    <button id="newGame" class="primary">New Game</button>
    <button id="newHand">New Hand</button>
    <span class="pill" id="handInfo">Hand 1 / 5</span>
    <span class="pill" id="turnInfo">Turn: ‚Äî</span>
  </div>
</header>

<div class="flyLayer" id="flyLayer"></div>

<div class="bottomBar">
  <button id="playBtnMobile" class="primary">Play</button>
  <button id="pickupBtnMobile" class="danger">Pick Up</button>
  <button id="hintBtnMobile">Hint</button>
</div>

<!-- Pass-and-play privacy overlay -->
<div class="overlay" id="passOverlay" role="dialog" aria-modal="true">
  <div class="overlayCard">
    <div class="bigAvatar" id="passAvatar"><span id="passEmoji">üôÇ</span><span class="init" id="passInit">P1</span></div>
    <h2 id="passTitle">Pass to Player</h2>
    <div class="sub" id="passSub">Only the current player‚Äôs cards will be visible.</div>
    <div class="overlayActions">
      <button id="readyBtn" class="primary">I‚Äôm ready</button>
      <button id="peekBtn">Show table only</button>
    </div>
  </div>
</div>

<main>
  <div class="grid">

    <!-- TABLE -->
    <section class="table">
      <div class="playersRow" id="playersRow"></div>

      <div class="note">
        <div class="pileRow">
          <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
            <span class="pill">Draw: <span id="drawCount">‚Äî</span></span>
            <span class="pill" id="discardPill">Discard: <span id="discardCount">‚Äî</span></span>
            <span class="pill">Pile: <span id="pileCount">‚Äî</span></span>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <span class="muted">Top:</span>
            <span class="pill" id="topValue">‚Äî</span>
          </div>
        </div>

        <div class="pileVisualWrap" id="pileVisualWrap"></div>

        <div class="muted" style="margin-top:10px;">
          Play same-rank cards. Must be ‚â§ top rank (A &lt; ‚Ä¶ &lt; K).
          <span class="kbd">10</span> and <span class="kbd">Joker</span> clear.
          <span class="kbd">3+</span> of same rank on pile clears.
          Face-down discovered on play. Illegal face-down ‚Üí pick up entire pile.
        </div>
      </div>

      <div class="zoneTitle">
        <span id="handLabel">Current player hand</span>
        <span class="muted">tap to select ¬∑ double-tap to quick-play</span>
      </div>
      <div id="yourHand" class="handScroll"></div>

      <div class="zoneTitle">
        <span id="tableLabel">Current player table</span>
        <span class="muted">hand + face-up can mix ¬∑ face-down alone</span>
      </div>
      <div id="yourTable" class="hand"></div>
    </section>

    <!-- SIDE PANEL -->
    <section class="panel">
      <div class="topActions" style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <button id="playBtn" class="primary">Play Selected</button>
        <button id="pickupBtn" class="danger">Pick Up Pile</button>
        <button id="hintBtn">Hint</button>
      </div>

      <div class="zoneTitle" style="margin-top:12px;">
        <span>Game Log</span>
        <span class="muted">newest first</span>
      </div>
      <div id="log" class="log"></div>

      <div class="zoneTitle" style="margin-top:12px;">
        <span>Shortcuts</span>
        <span class="muted"><span class="kbd">Enter</span> play ¬∑ <span class="kbd">P</span> pickup ¬∑ <span class="kbd">H</span> hint</span>
      </div>
    </section>

  </div>
</main>

<script>
(() => {
  // ======= Constants =======
  const SUITS = ["‚ô†","‚ô•","‚ô¶","‚ô£"];
  const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const RANK_ORDER = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const rankOrder = (rank) => RANK_ORDER.indexOf(rank);

  const EMOJIS = ["ü¶ä","üêº","üêØ","ü¶Å","üê∏","üêô","ü¶â","ü¶Ñ","üê≤","üê∂","üê±","üêµ"];

  const SEAT_COLORS = [
    ["#63b3ed","#7ee787"], // blue->green
    ["#f2cc60","#ff7b72"], // gold->red
    ["#a78bfa","#63b3ed"], // purple->blue
    ["#34d399","#f2cc60"], // green->gold
    ["#fb7185","#a78bfa"], // pink->purple
    ["#60a5fa","#fb7185"], // blue->pink
  ];

  const isJoker = c => c.rank === "JOKER";
  const isTenOrJoker = c => c.rank === "10" || isJoker(c);

  // Player types for hybrid readiness
  const PlayerType = { HUMAN:"HUMAN", BOT:"BOT", REMOTE:"REMOTE" };

  // Scoring (house)
  const scoreValue = (card) => {
    if (isJoker(card)) return 50;
    if (card.rank === "10") return 20;
    if (card.rank === "A") return 1;
    if (card.rank === "J" || card.rank === "Q" || card.rank === "K") return 10;
    return parseInt(card.rank, 10);
  };

  // ======= State =======
  const state = {
    numPlayers: 4,
    players: [],
    deck: [],
    discard: [],
    pile: [],
    pileTopRank: null,
    handIndex: 1,
    handsTotal: 5,
    currentPlayer: 0,
    mustPlayAny: false,
    gameOver: false,

    // pass-and-play privacy
    viewPlayer: null,        // which player's hand/table is visible right now
    revealedThisTurn: false, // must press "I'm ready" each turn to reveal
    peekOnly: false          // if true, show table but not hand
  };

  const el = (id) => document.getElementById(id);
  const logEl = el("log");
  const yourHandEl = el("yourHand");
  const yourTableEl = el("yourTable");
  const playersRowEl = el("playersRow");
  const pileVisualWrap = el("pileVisualWrap");
  const flyLayer = el("flyLayer");
  const discardPill = el("discardPill");

  // overlay elements
  const passOverlay = el("passOverlay");
  const passTitle = el("passTitle");
  const passSub = el("passSub");
  const passAvatar = el("passAvatar");
  const passEmoji = el("passEmoji");
  const passInit = el("passInit");
  const readyBtn = el("readyBtn");
  const peekBtn = el("peekBtn");

  // Selection for current view player
  let selected = new Set();
  let selectedSources = new Map();
  let uid = 0;
  const newId = () => (++uid).toString();

  // Double-tap detection
  let lastTap = { id: null, t: 0 };

  // ‚úÖ Seat mapping (visual only)
  const SEAT_CLASSES = ["seat-bottom","seat-left","seat-top","seat-right","seat-tl","seat-tr"];

  // ======= Log helpers =======
  function toneDot(tone){
    if (tone==="ok") return `<span class="ok">‚óè</span> `;
    if (tone==="warn") return `<span class="warn">‚óè</span> `;
    if (tone==="bad") return `<span class="bad">‚óè</span> `;
    return "";
  }
  function addLog(text, tone=""){
    const div = document.createElement("div");
    div.className = "line";
    div.innerHTML = `${toneDot(tone)}${text}`;
    logEl.prepend(div);
  }

  // ======= Animation helpers =======
  function flashBurst(){
    pileVisualWrap.classList.remove("burst");
    void pileVisualWrap.offsetWidth;
    pileVisualWrap.classList.add("burst");
  }
  function shakePile(){
    pileVisualWrap.classList.remove("shake");
    void pileVisualWrap.offsetWidth;
    pileVisualWrap.classList.add("shake");
  }
  function flyCardsToDiscard(count){
    const fromRect = pileVisualWrap.getBoundingClientRect();
    const toRect = discardPill.getBoundingClientRect();
    const startX = fromRect.left + fromRect.width * 0.50;
    const startY = fromRect.top + fromRect.height * 0.45;
    const endX = toRect.left + toRect.width * 0.55;
    const endY = toRect.top + toRect.height * 0.50;

    const n = Math.min(10, Math.max(3, Math.ceil(count / 6)));
    for (let i=0;i<n;i++){
      const fc = document.createElement("div");
      fc.className = "flyCard";
      fc.textContent = "üÇ†";
      fc.style.left = (startX + (Math.random()*18-9)) + "px";
      fc.style.top  = (startY + (Math.random()*18-9)) + "px";
      flyLayer.appendChild(fc);

      requestAnimationFrame(() => {
        const dx = (endX - startX) + (Math.random()*14-7);
        const dy = (endY - startY) + (Math.random()*14-7);
        const rot = (Math.random()*40 - 20);
        fc.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg) scale(.75)`;
        fc.style.opacity = "0.0";
      });

      setTimeout(()=>fc.remove(), 520);
    }
  }

  // ======= Core helpers =======
  function playerName(i){ return state.players[i]?.name ?? `Player ${i+1}`; }

  function initialsFromName(name){
    const parts = name.trim().split(/\s+/).filter(Boolean);
    if (parts.length === 0) return "P";
    if (parts.length === 1) return parts[0].slice(0,2).toUpperCase();
    return (parts[0][0] + parts[parts.length-1][0]).toUpperCase();
  }

  function seatGradient(i){
    const [a,b] = SEAT_COLORS[i % SEAT_COLORS.length];
    return `linear-gradient(135deg, ${a}, ${b})`;
  }

  function createPlayers(n){
    return Array.from({length:n}, (_,i)=>({
      id:i,
      type: PlayerType.HUMAN,          // default: all humans (multiplayer)
      name: `Player ${i+1}`,
      emoji: EMOJIS[i % EMOJIS.length],
      initials: `P${i+1}`,
      hand: [],
      tableUp: Array.from({length:4}, ()=>null),
      tableDown: Array.from({length:4}, ()=>null),
      score: 0
    }));
  }

  function resetSelection(){
    selected.clear();
    selectedSources.clear();
  }

  function topRank(){
    const top = state.pile[state.pile.length-1];
    return top ? top.rank : state.pileTopRank;
  }

  // ‚úÖ Correct play legality: rank hierarchy (NOT point values)
  function canPlayOnTop(rank){
    if (state.mustPlayAny) return true;
    const top = topRank();
    if (!top) return true;

    if (rank === "10" || rank === "JOKER") return true;
    if (top === "10" || top === "JOKER") return true;

    return rankOrder(rank) <= rankOrder(top);
  }

  function countRankOnPile(rank){
    return state.pile.reduce((acc,c)=> acc + (c.rank === rank ? 1 : 0), 0);
  }

  function checkTripleClear(){
    if (state.pile.length < 3) return false;
    const last = state.pile[state.pile.length-1];
    const r = last.rank;
    if (r === "JOKER") return false;
    return countRankOnPile(r) >= 3;
  }

  function clearPile(reason){
    const n = state.pile.length;
    if (n === 0) return;

    flashBurst();
    flyCardsToDiscard(n);

    state.discard.push(...state.pile);
    state.pile = [];
    state.mustPlayAny = true;

    addLog(`Pile cleared (${reason}). ${n} cards to discard. Play again (ANY).`, "ok");
  }

  function renderCardText(c){
    if (isJoker(c)) return "JOKER";
    return `${c.rank}${c.suit}`;
  }

  function makeDeck(){
    const deck = [];
    for (let d=0; d<2; d++){
      for (const s of SUITS){
        for (const r of RANKS){
          deck.push({ id:newId(), rank:r, suit:s });
        }
      }
    }
    // 4 jokers total
    for (let j=0; j<4; j++){
      deck.push({ id:newId(), rank:"JOKER", suit:"‚òÖ" });
    }
    for (let i=deck.length-1;i>0;i--){
      const k = Math.floor(Math.random()*(i+1));
      [deck[i], deck[k]] = [deck[k], deck[i]];
    }
    return deck;
  }

  function drawStartCard(){
    const c = state.deck.pop();
    state.pile.push(c);
    state.pileTopRank = c.rank;
    state.mustPlayAny = false;
    addLog(`Start card flipped: ${renderCardText(c)}.`, "warn");
  }

  function beginTurnRevealFlow(){
    state.viewPlayer = null;
    state.revealedThisTurn = false;
    state.peekOnly = false;

    const p = state.players[state.currentPlayer];
    passTitle.textContent = `Pass to ${p.name}`;
    passSub.textContent = `Only ${p.name}‚Äôs cards will be visible.`;
    passEmoji.textContent = p.emoji;
    passInit.textContent = p.initials;
    passAvatar.style.background = seatGradient(p.id);

    passOverlay.classList.add("show");
    render(); // will render hidden zones
  }

  function endOverlayReveal(peekOnly){
    state.viewPlayer = state.currentPlayer;
    state.revealedThisTurn = true;
    state.peekOnly = !!peekOnly;
    passOverlay.classList.remove("show");
    render();
  }

  function dealHand(){
    resetSelection();
    state.deck = makeDeck();
    state.discard = [];
    state.pile = [];
    state.mustPlayAny = false;
    state.gameOver = false;

    for (const p of state.players){
      p.hand = [];
      p.tableUp = Array.from({length:4}, ()=>null);
      p.tableDown = Array.from({length:4}, ()=>null);
    }

    for (let i=0;i<4;i++){
      for (const p of state.players){
        p.tableDown[i] = state.deck.pop();
      }
    }
    for (let i=0;i<4;i++){
      for (const p of state.players){
        p.tableUp[i] = state.deck.pop();
      }
    }
    for (let i=0;i<11;i++){
      for (const p of state.players){
        p.hand.push(state.deck.pop());
      }
    }

    drawStartCard();
    state.currentPlayer = 0;

    addLog(`New hand dealt. ${state.players[state.currentPlayer].name} starts.`, "ok");
    beginTurnRevealFlow();
  }

  // ======= Rendering helpers =======
  function rankSortKey(r){
    if (r === "JOKER") return 99;
    return Math.max(0, RANK_ORDER.indexOf(r)) + 1;
  }

  function makeRealCardDiv(card, opts){
    const div = document.createElement("div");
    const selectable = !!opts.selectable;
    const selectedOn = !!opts.selectedOn;
    const back = !!opts.back;

    div.className = "c" + (selectable ? " selectable" : "") + (selectedOn ? " selected" : "");
    if (back){
      div.classList.add("back");
      div.innerHTML = `
        <div class="pip" style="color:rgba(255,255,255,.9)">üÇ†</div>
        <div class="subpip" style="color:rgba(255,255,255,.85)">SPLASH</div>
      `;
      return div;
    }

    if (isJoker(card)){
      div.classList.add("joker");
      div.classList.add("black");
      div.innerHTML = `
        <div class="corner top">JOKER<br>‚òÖ</div>
        <div class="pip">‚òÖ</div>
        <div class="subpip">JOKER</div>
        <div class="corner bottom">JOKER<br>‚òÖ</div>
      `;
      return div;
    }

    const isRed = card.suit === "‚ô•" || card.suit === "‚ô¶";
    div.classList.add(isRed ? "red" : "black");

    const rank = card.rank;
    const suit = card.suit;

    div.innerHTML = `
      <div class="corner top">${rank}<br>${suit}</div>
      <div class="pip">${suit}</div>
      <div class="corner bottom">${rank}<br>${suit}</div>
    `;
    return div;
  }

  function renderSelectableCard(card, src){
    const selectedOn = selected.has(card.id);
    const div = makeRealCardDiv(card, { selectable:true, selectedOn, back:false });

    const legal = canPlayOnTop(card.rank);
    if (!legal && !state.mustPlayAny) div.classList.add("illegal");

    div.onclick = () => {
      const now = Date.now();
      const isDouble = (lastTap.id === card.id && (now - lastTap.t) < 320);
      lastTap = { id: card.id, t: now };
      if (isDouble) {
        quickPlayRank(card.rank);
        return;
      }
      toggleSelect(card, src);
    };

    return div;
  }

  function toggleSelect(card, src){
    if (selected.has(card.id)){
      selected.delete(card.id);
      selectedSources.delete(card.id);
    } else {
      selected.add(card.id);
      selectedSources.set(card.id, src);
    }
    render();
  }

  function selectedCards(){
    const p = state.players[state.viewPlayer];
    if (!p) return [];
    const all = [];
    for (const [id, src] of selectedSources.entries()){
      let card = null;
      if (src.zone === "hand"){
        card = p.hand.find(c=>c.id===id);
      } else if (src.zone === "tableUp"){
        card = p.tableUp[src.stackIndex];
      } else if (src.zone === "tableDown"){
        card = p.tableDown[src.stackIndex];
      }
      if (card) all.push({card, src});
    }
    return all;
  }

  function validateSelection(playList){
    if (playList.length === 0) return {ok:false, msg:"Select at least one card."};

    const downCount = playList.filter(x=>x.src.zone==="tableDown").length;
    if (downCount > 1) return {ok:false, msg:"Play face-down cards one at a time (discover-on-play)."};

    if (downCount === 1){
      if (playList.length !== 1) return {ok:false, msg:"Face-down must be played alone."};
      return {ok:true, msg:"Face-down play."};
    }

    const ranks = new Set(playList.map(x=>x.card.rank));
    if (ranks.size !== 1) return {ok:false, msg:"All played cards must be the same rank."};
    const r = playList[0].card.rank;

    if (!canPlayOnTop(r)) return {ok:false, msg:`Illegal: must be ‚â§ top (${topRank()}) unless you have ANY.`};
    return {ok:true, msg:"OK"};
  }

  function removeCardFromSource(player, card, src){
    if (src.zone === "hand"){
      player.hand = player.hand.filter(c=>c.id !== card.id);
    } else if (src.zone === "tableUp"){
      player.tableUp[src.stackIndex] = null;
    } else if (src.zone === "tableDown"){
      player.tableDown[src.stackIndex] = null;
    }
  }

  function pickupPile(player){
    if (state.pile.length === 0){
      addLog(`${player.name} tried to pick up, but pile is empty.`, "warn");
      return;
    }
    shakePile();
    player.hand.push(...state.pile);
    addLog(`${player.name} picks up the pile (${state.pile.length} cards).`, "bad");
    state.pile = [];
    state.mustPlayAny = true;
  }

  function playCards(player, playList){
    if (playList.length === 1 && playList[0].src.zone === "tableDown"){
      const {card, src} = playList[0];
      addLog(`${player.name} plays face-down ‚Üí revealed ${renderCardText(card)}.`, "warn");

      if (!canPlayOnTop(card.rank)){
        state.pile.push(card);
        removeCardFromSource(player, card, src);
        render();
        pickupPile(player);
        return {extraTurn:false};
      }

      state.pile.push(card);
      removeCardFromSource(player, card, src);

      if (isTenOrJoker(card)){
        clearPile(`${renderCardText(card)} clears`);
        return {extraTurn:true};
      }
      if (checkTripleClear()){
        clearPile(`triple of ${card.rank}`);
        return {extraTurn:true};
      }
      state.mustPlayAny = false;
      return {extraTurn:false};
    }

    const rank = playList[0].card.rank;
    addLog(`${player.name} plays ${playList.length} √ó ${rank}.`);

    for (const {card, src} of playList){
      state.pile.push(card);
      removeCardFromSource(player, card, src);
    }

    if (rank === "10" || rank === "JOKER"){
      clearPile(`${rank} clears`);
      return {extraTurn:true};
    }
    if (checkTripleClear()){
      clearPile(`triple of ${rank}`);
      return {extraTurn:true};
    }

    state.mustPlayAny = false;
    return {extraTurn:false};
  }

  function playerRemaining(player){
    return player.hand.length + player.tableUp.filter(Boolean).length + player.tableDown.filter(Boolean).length;
  }

  function endHandIfNeeded(){
    const winner = state.players.find(p => playerRemaining(p) === 0);
    if (!winner) return false;

    addLog(`üèÅ ${winner.name} wins the hand!`, "ok");

    state.players.forEach(p => {
      if (p.id === winner.id) return;
      const remainingCards = [
        ...p.hand,
        ...p.tableUp.filter(Boolean),
        ...p.tableDown.filter(Boolean)
      ];
      const pts = remainingCards.reduce((sum,c)=>sum+scoreValue(c),0);
      p.score += pts;
      addLog(`${p.name} scores ${pts} points (remaining cards).`, "warn");
    });

    if (state.handIndex >= state.handsTotal){
      state.gameOver = true;
      const standings = state.players
        .map(p => ({name:p.name, score:p.score}))
        .sort((a,b)=>a.score-b.score);
      addLog(`üéâ Game over. Winner: ${standings[0].name} with ${standings[0].score} points.`, "ok");
    } else {
      state.handIndex += 1;
      addLog(`Next: Hand ${state.handIndex} / ${state.handsTotal}. Click "New Hand".`, "ok");
    }
    render();
    return true;
  }

  function nextPlayer(){
    state.currentPlayer = (state.currentPlayer + 1) % state.numPlayers;
    resetSelection();
    beginTurnRevealFlow();
  }

  function computeLegalPlays(player){
    const ranks = [];
    const addRank = (r) => { if (!ranks.includes(r)) ranks.push(r); };

    const cards = [...player.hand, ...player.tableUp.filter(Boolean)];
    const byRank = new Map();
    for (const c of cards){
      const r = c.rank;
      if (!byRank.has(r)) byRank.set(r, []);
      byRank.get(r).push(c);
    }

    for (const r of byRank.keys()){
      if (canPlayOnTop(r)) addRank(r);
    }
    return {ranks, byRank};
  }

  function penaltyPriority(rank){
    if (rank === "JOKER") return 100;
    if (rank === "10") return 60;
    if (rank === "K" || rank === "Q" || rank === "J") return 40;
    if (rank === "A") return 1;
    return rankOrder(rank) + 2;
  }

  function botTakeTurn(bot){
    const {ranks, byRank} = computeLegalPlays(bot);
    if (ranks.length === 0){
      pickupPile(bot);
      return {extraTurn:false};
    }
    if (ranks.includes("10") || ranks.includes("JOKER")){
      const r = ranks.includes("10") ? "10" : "JOKER";
      const c = byRank.get(r)[0];
      const src = bot.hand.find(x=>x.id===c.id)
        ? {zone:"hand"}
        : {zone:"tableUp", stackIndex: bot.tableUp.findIndex(x=>x && x.id===c.id)};
      return playCards(bot, [{card:c, src}]);
    }
    let chosenRank;
    if (state.mustPlayAny){
      chosenRank = ranks.slice().sort((a,b)=> penaltyPriority(b)-penaltyPriority(a))[0];
    } else {
      chosenRank = ranks.slice().sort((a,b)=> rankOrder(b)-rankOrder(a))[0];
    }
    const toPlay = byRank.get(chosenRank).map(c=>({
      card:c,
      src: bot.hand.find(x=>x.id===c.id)
        ? {zone:"hand"}
        : {zone:"tableUp", stackIndex: bot.tableUp.findIndex(x=>x && x.id===c.id)}
    }));
    return playCards(bot, toPlay);
  }

  function quickPlayRank(rank){
    if (!isTurnPlayable()) return;
    const p = state.players[state.currentPlayer];
    if (!p || state.viewPlayer !== state.currentPlayer) return;
    if (state.peekOnly) return;

    const playList = [];
    for (const c of p.hand){
      if (c.rank === rank) playList.push({card:c, src:{zone:"hand"}});
    }
    for (let i=0;i<4;i++){
      const up = p.tableUp[i];
      if (up && up.rank === rank) playList.push({card:up, src:{zone:"tableUp", stackIndex:i}});
    }
    if (playList.length === 0) return;

    if (!canPlayOnTop(rank)){
      addLog(`‚ùå Illegal: ${rank} is higher than top (${topRank()}).`, "bad");
      return;
    }

    resetSelection();
    const res = playCards(p, playList);
    render();
    if (endHandIfNeeded()) return;
    if (res.extraTurn) return;
    nextPlayer();
  }

  function isTurnPlayable(){
    if (state.gameOver) return false;
    if (!state.revealedThisTurn) return false;
    if (state.viewPlayer !== state.currentPlayer) return false;
    const p = state.players[state.currentPlayer];
    if (!p) return false;
    return p.type === PlayerType.HUMAN;
  }

  function humanPlay(){
    if (!isTurnPlayable()) return;
    if (state.peekOnly) return;
    const p = state.players[state.currentPlayer];

    const playList = selectedCards();
    const v = validateSelection(playList);
    if (!v.ok){
      addLog(`‚ùå ${v.msg}`, "bad");
      return;
    }

    resetSelection();
    const res = playCards(p, playList);
    render();
    if (endHandIfNeeded()) return;
    if (res.extraTurn) return;
    nextPlayer();
  }

  function humanPickup(){
    if (!isTurnPlayable()) return;
    const p = state.players[state.currentPlayer];
    resetSelection();
    pickupPile(p);
    render();
    nextPlayer();
  }

  function humanHint(){
    if (!isTurnPlayable()) return;
    if (state.peekOnly) return;
    const p = state.players[state.currentPlayer];

    const anyPlayableKnown = (p.hand.length + p.tableUp.filter(Boolean).length) > 0;
    if (!anyPlayableKnown){
      const candidates = p.tableDown.map((c,i)=>({c,i})).filter(x=>x.c && !p.tableUp[x.i]);
      addLog(candidates.length
        ? `Hint: you must play a face-down card (choose any stack).`
        : `Hint: you have no cards left (hand should end).`,
        "warn"
      );
      return;
    }

    const {ranks, byRank} = computeLegalPlays(p);
    if (ranks.length === 0){
      addLog(`Hint: no legal play from hand/face-up ‚Üí pick up the pile.`, "warn");
      return;
    }

    for (const r of ranks){
      if (r==="10" || r==="JOKER") continue;
      const existing = countRankOnPile(r);
      const needed = Math.max(0, 3 - existing);
      const have = (byRank.get(r) || []).length;
      if (needed > 0 && have >= needed){
        addLog(`Hint: play ${needed}√ó${r} to complete a triple and clear.`, "ok");
        return;
      }
    }

    if (ranks.includes("10") || ranks.includes("JOKER")){
      addLog(`Hint: 10/Joker clears instantly.`, "ok");
      return;
    }

    const best = ranks.slice().sort((a,b)=> rankOrder(b)-rankOrder(a))[0];
    addLog(`Hint: play ${best} (highest legal) to restrict others.`, "ok");
  }

  function renderPileVisual(){
    pileVisualWrap.innerHTML = "";
    const slice = state.pile.slice(-6);
    slice.forEach((c, i) => {
      const d = makeRealCardDiv(c, { selectable:false, selectedOn:false, back:false });
      d.classList.add("pileCard");
      const rot = (Math.random()*2-1);
      d.style.transform = `translate(${i*12}px, ${i*4}px) rotate(${rot}deg)`;
      if (i === slice.length-1) d.classList.add("anim-pop");
      pileVisualWrap.appendChild(d);
    });
  }

  /* ‚úÖ ONLY MODIFIED FUNCTION: renderPlayersRow adds seat class */
  function renderPlayersRow(){
    playersRowEl.innerHTML = "";
    state.players.forEach((p, idx) => {
      const chip = document.createElement("div");
      const seatClass = SEAT_CLASSES[idx] || "seat-top";
      chip.className = "playerChip " + seatClass + (idx === state.currentPlayer ? " active" : "");

      const remaining = playerRemaining(p);
      const upN = p.tableUp.filter(Boolean).length;
      const downN = p.tableDown.filter(Boolean).length;

      chip.innerHTML = `
        <div class="avatar" style="background:${seatGradient(p.id)}">
          <div class="emo">${p.emoji}</div>
          <div class="init">${p.initials}</div>
        </div>
        <div>
          <div class="pname">${p.name} <span class="pmeta">(${p.score} pts)</span></div>
          <div class="pstats">
            <span>Hand ${p.hand.length}</span>
            <span>Up ${upN}</span>
            <span>Down ${downN}</span>
            <span>Total ${remaining}</span>
          </div>
        </div>
      `;
      playersRowEl.appendChild(chip);
    });
  }

  function renderZonesHidden(){
    yourHandEl.innerHTML = "";
    yourTableEl.innerHTML = "";
    for (let i=0;i<5;i++){
      const back = makeRealCardDiv({rank:"X", suit:""}, {selectable:false, selectedOn:false, back:true});
      back.style.opacity = "0.55";
      yourHandEl.appendChild(back);
    }
    for (let i=0;i<4;i++){
      const back = makeRealCardDiv({rank:"X", suit:""}, {selectable:false, selectedOn:false, back:true});
      back.style.opacity = "0.55";
      yourTableEl.appendChild(back);
    }
  }

  function renderZonesForPlayer(pid){
    const p = state.players[pid];
    if (!p) return;

    el("handLabel").textContent = `${p.name} hand`;
    el("tableLabel").textContent = `${p.name} table`;

    yourHandEl.innerHTML = "";
    if (state.peekOnly){
      for (let i=0;i<Math.min(7, Math.max(3, p.hand.length ? 5 : 3)); i++){
        const back = makeRealCardDiv({rank:"X", suit:""}, {selectable:false, selectedOn:false, back:true});
        yourHandEl.appendChild(back);
      }
    } else {
      p.hand
        .slice()
        .sort((a,b) => (rankSortKey(a.rank) - rankSortKey(b.rank)))
        .forEach(card => {
          yourHandEl.appendChild(renderSelectableCard(card, {zone:"hand"}));
        });
    }

    yourTableEl.innerHTML = "";
    for (let i=0;i<4;i++){
      const up = p.tableUp[i];
      const down = p.tableDown[i];

      if (up){
        yourTableEl.appendChild(renderSelectableCard(up, {zone:"tableUp", stackIndex:i}));
      } else {
        if (down){
          const back = makeRealCardDiv(down, { selectable:true, selectedOn:selected.has(down.id), back:true });
          back.onclick = () => {
            if (!isTurnPlayable()) return;
            if (selected.has(down.id)){
              selected.delete(down.id);
              selectedSources.delete(down.id);
            } else {
              resetSelection();
              selected.add(down.id);
              selectedSources.set(down.id, {zone:"tableDown", stackIndex:i});
            }
            render();
          };
          yourTableEl.appendChild(back);
        } else {
          const empty = document.createElement("div");
          empty.className = "c back";
          empty.style.opacity = "0.35";
          empty.innerHTML = `<div class="pip" style="color:rgba(255,255,255,.9)">‚Äî</div><div class="subpip" style="color:rgba(255,255,255,.8)">EMPTY</div>`;
          yourTableEl.appendChild(empty);
        }
      }
    }
  }

  function render(){
    el("drawCount").textContent = state.deck.length.toString();
    el("discardCount").textContent = state.discard.length.toString();
    el("pileCount").textContent = state.pile.length.toString();
    el("handInfo").textContent = `Hand ${state.handIndex} / ${state.handsTotal}`;
    el("turnInfo").textContent = `Turn: ${playerName(state.currentPlayer)}`;
    el("topValue").textContent = state.mustPlayAny ? "ANY" : (topRank() ? topRank() : "‚Äî");

    renderPlayersRow();
    renderPileVisual();

    if (!state.revealedThisTurn || state.viewPlayer === null){
      el("handLabel").textContent = `Current player hand`;
      el("tableLabel").textContent = `Current player table`;
      renderZonesHidden();
    } else {
      renderZonesForPlayer(state.viewPlayer);
    }

    const playable = isTurnPlayable();
    el("playBtn").disabled = !playable || state.peekOnly;
    el("pickupBtn").disabled = !playable;
    el("hintBtn").disabled = !playable || state.peekOnly;
    el("playBtnMobile").disabled = !playable || state.peekOnly;
    el("pickupBtnMobile").disabled = !playable;
    el("hintBtnMobile").disabled = !playable || state.peekOnly;
  }

  el("newGame").onclick = () => {
    state.numPlayers = parseInt(el("numPlayers").value, 10);
    state.players = createPlayers(state.numPlayers);
    state.players.forEach((p,i)=>{ p.initials = initialsFromName(p.name) || `P${i+1}`; });
    state.handIndex = 1;
    logEl.innerHTML = "";
    addLog(`New game started with ${state.numPlayers} players (local multiplayer).`, "ok");
    dealHand();
  };

  el("newHand").onclick = () => {
    if (state.gameOver){
      addLog(`Game is over. Click "New Game" to restart.`, "warn");
      return;
    }
    dealHand();
  };

  el("playBtn").onclick = humanPlay;
  el("pickupBtn").onclick = humanPickup;
  el("hintBtn").onclick = humanHint;

  el("playBtnMobile").onclick = humanPlay;
  el("pickupBtnMobile").onclick = humanPickup;
  el("hintBtnMobile").onclick = humanHint;

  window.addEventListener("keydown", (e) => {
    if (passOverlay.classList.contains("show")) return;
    if (e.key === "Enter") humanPlay();
    if (e.key.toLowerCase() === "p") humanPickup();
    if (e.key.toLowerCase() === "h") humanHint();
  });

  readyBtn.onclick = () => endOverlayReveal(false);
  peekBtn.onclick = () => endOverlayReveal(true);

  state.numPlayers = parseInt(el("numPlayers").value, 10);
  state.players = createPlayers(state.numPlayers);
  state.players.forEach((p,i)=> p.initials = initialsFromName(p.name) || `P${i+1}`);
  addLog(`Ready. Click "New Game" to begin (local multiplayer).`, "ok");
  render();
})();
</script>
</body>
</html>
