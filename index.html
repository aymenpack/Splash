<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Splash</title>

  <style>
    :root{
      --bg:#0b1220;
      --table1:#12204a;
      --table2:#0c1430;
      --panel:rgba(255,255,255,.04);
      --panelBorder:rgba(255,255,255,.10);
      --accent:#63b3ed;
      --danger:#ff7b72;
      --ok:#7ee787;
      --muted:rgba(230,237,247,.72);
      --shadow:0 10px 26px rgba(0,0,0,.45);
      --card-w: clamp(46px, 8.6vw, 76px);
      --card-h: calc(var(--card-w) * 1.45);
      --avatar:44px;
      --pile-h:130px;
      --gap:8px;
    }

    *{ box-sizing:border-box; }

    /* ‚úÖ NO PAGE SCROLL */
    html,body{
      height:100%;
      margin:0;
      overflow:hidden;
    }

    body{
      color:#e6edf7;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(circle at top, #142046, var(--bg) 60%);
      -webkit-tap-highlight-color: transparent;
    }

    header{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    header h1{
      margin:0;
      font-size:15px;
      font-weight:900;
      letter-spacing:.2px;
      white-space:nowrap;
    }

    select,button,input{
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.16);
      color:#e6edf7;
      padding:8px 12px;
      border-radius:12px;
      font-size:13px;
      outline:none;
    }

    button{ cursor:pointer; }
    button.primary{ background:rgba(99,179,237,.22); border-color:rgba(99,179,237,.45); }
    button.danger{ background:rgba(255,123,114,.18); border-color:rgba(255,123,114,.45); }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .muted{ color:var(--muted); font-size:12px; }
    .pill{
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      font-size:12px;
      display:inline-flex;
      gap:6px;
      align-items:center;
      white-space:nowrap;
    }

    /* ======== App layout: fixed viewport, no scroll ======== */
    #app{
      height:100%;
      display:flex;
      flex-direction:column;
    }

    main{
      flex:1;
      min-height:0;
      max-height:100%;
      padding:10px 10px calc(10px + env(safe-area-inset-bottom));
      overflow:hidden; /* ‚úÖ no scroll */
    }

    .grid{
      height:100%;
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }

    /* Desktop can show side panel area but still no page scroll */
    @media (min-width: 1200px){
      .grid{ grid-template-columns: 1fr 380px; }
    }

    .table{
      height:100%;
      background: linear-gradient(180deg, var(--table1), var(--table2));
      border-radius:20px;
      padding:10px;
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      min-height:0;
      overflow:hidden;
    }

    .playersRow{
      position:relative;
      height:160px;
      margin-bottom:8px;
      flex:0 0 auto;
    }

    .playerChip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:14px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      min-width:150px;
      position:absolute;
    }

    .playerChip.active{
      outline:2px solid var(--accent);
      box-shadow:0 0 16px rgba(99,179,237,.45);
    }

    .seat-bottom{ left:50%; bottom:0; transform:translateX(-50%); }
    .seat-top{ left:50%; top:0; transform:translateX(-50%); }
    .seat-left{ left:0; top:50%; transform:translateY(-50%); }
    .seat-right{ right:0; top:50%; transform:translateY(-50%); }
    .seat-tl{ left:0; top:0; transform:none; }
    .seat-tr{ right:0; top:0; transform:none; }

    .avatar{
      width:var(--avatar);
      height:var(--avatar);
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      color:#0b1220;
      position:relative;
      background:rgba(255,255,255,.9);
    }

    .avatar .emo{ font-size:20px; }
    .avatar .init{
      position:absolute;
      bottom:-2px; right:-2px;
      font-size:10px;
      padding:1px 5px;
      border-radius:999px;
      background:#000;
      color:#fff;
    }

    /* Compact players on mobile/tablet */
    @media (max-width: 900px){
      .playersRow{
        position:static;
        height:auto;
        display:grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap:8px;
        margin-bottom:8px;
      }
      .playerChip{ position:static; transform:none !important; min-width:0; }
    }

    .c{
      width:var(--card-w);
      height:var(--card-h);
      border-radius:12px;
      background:#fff;
      color:#111;
      position:relative;
      box-shadow:0 6px 18px rgba(0,0,0,.45);
      transition:.12s ease;
      touch-action:none;
      user-select:none;
    }

    .c.selectable{ cursor:pointer; }
    .c.selectable:hover{ transform:translateY(-3px); }
    .c.selected{ outline:3px solid var(--accent); transform:translateY(-4px); }
    .c.illegal{ opacity:.55; pointer-events:none; }
    .c.dragging{ outline:3px solid rgba(99,179,237,.55); transform:scale(1.03); }

    .corner{
      position:absolute;
      font-weight:900;
      font-size:12px;
      line-height:1;
    }
    .corner.top{ top:6px; left:6px; }
    .corner.bottom{ bottom:6px; right:6px; transform:rotate(180deg); }

    .pip{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      font-size:30px;
    }

    @media(max-width:600px){
      .corner{ font-size:11px; }
      .pip{ font-size:24px; }
    }

    .note{
      padding:8px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      flex:0 0 auto;
    }

    .pileRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }

    .pileVisualWrap{
      width:100%;
      height:var(--pile-h);
      border-radius:16px;
      border:2px dashed rgba(255,255,255,.18);
      background:rgba(0,0,0,.18);
      margin-top:8px;
      position:relative;
      overflow:hidden;
      transition:.15s ease;
    }
    .pileVisualWrap.dragOver{
      border-color: var(--accent);
      background: rgba(99,179,237,.14);
    }

    .zoneTitle{
      margin:8px 0 6px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      flex:0 0 auto;
    }

    /* ‚úÖ FORCE 5 PER ROW (no horizontal scroll) */
    .handScroll{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:6px;
      justify-items:center;
      flex:1 1 auto;
      min-height:0;
      overflow:hidden; /* ‚úÖ no scroll */
    }

    .hand{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:6px;
      justify-items:center;
      flex:0 0 auto;
      overflow:hidden;
    }

    /* ===== Action panel fixed, no page scroll ===== */
    .panel{
      background:rgba(255,255,255,.04);
      border-radius:18px;
      padding:10px;
      border:1px solid rgba(255,255,255,.10);
      display:flex;
      flex-direction:column;
      gap:10px;
      height:100%;
      min-height:0;
      overflow:hidden;
    }

    /* On mobile/tablet, keep actions always visible */
    @media (max-width: 900px){
      .panel{
        position:fixed;
        left:10px;
        right:10px;
        bottom: calc(10px + env(safe-area-inset-bottom));
        z-index:1000;
        backdrop-filter: blur(10px);
      }
      main{ padding-bottom: 160px; }
      /* Hide secondary column on mobile since panel is floating */
      @media (max-width: 900px){
        .grid{ grid-template-columns: 1fr; }
      }
    }

    .ok{ color:var(--ok); }
    .warn{ color:#f2cc60; }
    .bad{ color:var(--danger); }

    .mpbar{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
      margin-left:auto;
    }
    .mpbar input{ width:95px; }
    .mpbar #mpRoom{ text-transform:uppercase; width:90px; }
    .mpStatus{ font-size:12px; opacity:.7; }
    .mpStatus.connected{ color: var(--ok); }
    .mpStatus.error{ color: var(--danger); }

    .connectionIndicator{
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--danger);
      display: inline-block;
      margin-right: 6px;
    }
    .connectionIndicator.connected{
      background: var(--ok);
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* ===== Log drawer (no scrolling the page) ===== */
    #logDrawer{
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      height:45%;
      background:rgba(10,14,30,.96);
      border-top:1px solid rgba(255,255,255,.15);
      transform:translateY(100%);
      transition:.25s ease;
      z-index:3000;
      display:flex;
      flex-direction:column;
    }
    #logDrawer.open{ transform:translateY(0); }

    #logToggle{
      position:absolute;
      top:-30px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(20,25,50,.95);
      border:1px solid rgba(255,255,255,.2);
      border-radius:14px;
      padding:4px 12px;
      font-size:16px;
      cursor:pointer;
      user-select:none;
    }

    .log{
      padding:10px;
      font-family:ui-monospace,monospace;
      font-size:12px;
      overflow:auto;
      min-height:0;
    }
    .log .line{ padding:2px 0; border-bottom:1px dashed rgba(255,255,255,.07); }
    .log .line:last-child{ border-bottom:none; }

    /* Compact action row inside panel */
    .actionRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .actionRow button{ flex:1; }

    .topRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
  </style>
</head>

<body>
<div id="app">
<header>
  <h1>üÉè Splash</h1>

  <div class="mpbar">
    <input id="mpName" placeholder="Name" />
    <input id="mpRoom" placeholder="ROOM" />
    <button id="hostBtn" class="primary">Host</button>
    <button id="joinBtn" class="primary">Join</button>
    <button id="leaveBtn" class="danger" style="display:none;">Leave</button>
    <span id="mpStatus" class="mpStatus"></span>
  </div>

  <div class="controls">
    <button id="newGame" class="primary">New Game</button>
    <span class="pill" id="turnInfo">Turn: ‚Äî</span>
  </div>
</header>

<main>
  <div class="grid">

    <section class="table">
      <div class="playersRow" id="playersRow"></div>

      <div class="note">
        <div class="pileRow">
          <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
            <span class="pill">Deck: <span id="deckCount">‚Äî</span></span>
            <span class="pill">Discard: <span id="discardCount">‚Äî</span></span>
            <span class="pill">Pile: <span id="pileCount">‚Äî</span></span>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <span class="muted">Top:</span>
            <span class="pill" id="topValue">‚Äî</span>
          </div>
        </div>

        <div class="pileVisualWrap" id="pileVisualWrap"></div>

        <div class="muted" style="margin-top:8px;">
          Mobile: drag a card onto the pile to play. No scrolling required.
        </div>
      </div>

      <div class="zoneTitle">
        <span id="handLabel">Your hand</span>
        <span class="muted" id="turnHint"></span>
      </div>
      <div id="yourHand" class="handScroll"></div>

      <div class="zoneTitle">
        <span id="tableLabel">Your table cards</span>
      </div>
      <div id="yourTable" class="hand"></div>
    </section>

    <section class="panel">
      <div class="topRow">
        <span class="pill" id="turnPill">‚Äî</span>
        <button id="logOpenBtn" class="primary" style="margin-left:auto;">‚¨Ü Log</button>
      </div>

      <div class="actionRow">
        <button id="playBtn" class="primary">Play Selected</button>
        <button id="pickupBtn" class="danger">Pick Up Pile</button>
      </div>

      <div class="muted" style="font-size:12px;">
        Tip: on mobile you can drag a card to the pile instead of tapping Play.
      </div>
    </section>

  </div>
</main>
</div>

<!-- Log Drawer -->
<div id="logDrawer">
  <div id="logToggle">‚¨Ü</div>
  <div id="log" class="log"></div>
</div>

<script>
(() => {
  const WS_BASE = "wss://splash-multiplayer.azimaymen.workers.dev";
  const mpClientId = crypto.randomUUID();
  let mpWs = null;
  let mpRoom = null;
  let mpConnected = false;
  let mySeat = null;
  let reconnectAttempts = 0;
  let reconnectTimer = null;
  const MAX_RECONNECT_ATTEMPTS = 5;

  // drag state
  const drag = { active:false, cardId:null, el:null, pid:null, moved:false, sx:0, sy:0 };

  function saveConnectionInfo(room, name, isHost) {
    localStorage.setItem('splash_room', room);
    localStorage.setItem('splash_name', name);
    localStorage.setItem('splash_isHost', isHost.toString());
  }
  function clearConnectionInfo() {
    localStorage.removeItem('splash_room');
    localStorage.removeItem('splash_name');
    localStorage.removeItem('splash_isHost');
  }
  function loadConnectionInfo() {
    return {
      room: localStorage.getItem('splash_room'),
      name: localStorage.getItem('splash_name'),
      isHost: localStorage.getItem('splash_isHost') === 'true'
    };
  }

  function mpSetStatus(t, type = 'normal') {
    const status = document.getElementById("mpStatus");
    const indicator = '<span class="connectionIndicator' + (type === 'connected' ? ' connected' : '') + '"></span>';
    status.innerHTML = indicator + t;
    status.className = 'mpStatus ' + type;
  }

  function mpSendJoin(isHost) {
    if (!mpWs || mpWs.readyState !== WebSocket.OPEN) return;
    mpWs.send(JSON.stringify({
      type: "join",
      id: mpClientId,
      name: document.getElementById("mpName").value || (isHost ? "Host" : "Player"),
      isHost: isHost
    }));
  }

  function mpConnect(room, isHost) {
    mpRoom = room.toUpperCase();
    mpWs = new WebSocket(`${WS_BASE}?room=${mpRoom}`);

    const name = document.getElementById("mpName").value || (isHost ? "Host" : "Player");
    saveConnectionInfo(mpRoom, name, isHost);

    mpWs.onopen = () => {
      mpConnected = true;
      reconnectAttempts = 0;
      mpSetStatus(`${mpRoom}${isHost ? " (HOST)" : ""}`, 'connected');
      mpSendJoin(isHost);
      document.getElementById("hostBtn").style.display = "none";
      document.getElementById("joinBtn").style.display = "none";
      document.getElementById("leaveBtn").style.display = "inline-block";
      logLine(`Connected to room ${mpRoom}`, "ok");
    };

    mpWs.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "players") {
        mySeat = msg.players.findIndex(p => p.id === mpClientId);
        ensurePlayersFromServer(msg.players);
        render();
      }

      if (msg.type === "state") {
        const payload = msg.payload;
        applyRemoteState(payload.state);
      }

      if (msg.type === "reset") {
        logLine("Game was reset by host", "warn");
        resetLocalState();
        render();
      }

      if (msg.type === "pong") {}
    };

    mpWs.onclose = () => {
      mpConnected = false;
      mpSetStatus("Disconnected", "error");
      handleReconnect(room, isHost);
    };

    mpWs.onerror = () => {
      mpConnected = false;
      mpSetStatus("Connection Error", "error");
    };

    setInterval(() => {
      if (mpWs && mpWs.readyState === WebSocket.OPEN) {
        mpWs.send(JSON.stringify({ type: "ping" }));
      }
    }, 30000);
  }

  function handleReconnect(room, isHost) {
    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      logLine("Failed to reconnect after multiple attempts", "bad");
      mpSetStatus("Disconnected - Reload to try again", "error");
      return;
    }

    reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
    mpSetStatus(`Reconnecting... (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, "error");

    reconnectTimer = setTimeout(() => {
      logLine(`Reconnecting (attempt ${reconnectAttempts})...`, "warn");
      mpConnect(room, isHost);
    }, delay);
  }

  // ‚úÖ server-authoritative action sender
  function mpSendAction(actionType, nextState) {
    if (!mpWs || mpWs.readyState !== WebSocket.OPEN) {
      logLine("Cannot sync - not connected", "warn");
      return;
    }
    mpWs.send(JSON.stringify({
      type: "action",
      action: {
        type: actionType,
        state: JSON.parse(JSON.stringify(nextState))
      }
    }));
  }

  function mpLeave() {
    if (reconnectTimer) clearTimeout(reconnectTimer);
    if (mpWs) mpWs.close();
    mpConnected = false;
    mpRoom = null;
    mySeat = null;
    clearConnectionInfo();
    document.getElementById("hostBtn").style.display = "inline-block";
    document.getElementById("joinBtn").style.display = "inline-block";
    document.getElementById("leaveBtn").style.display = "none";
    mpSetStatus("Not connected");
    logLine("Left room", "warn");
    resetLocalState();
    render();
  }

  document.getElementById("hostBtn").onclick = () => {
    const name = document.getElementById("mpName").value.trim();
    if (!name) return alert("Enter your name first");
    const code = Math.random().toString(36).slice(2, 8).toUpperCase();
    document.getElementById("mpRoom").value = code;
    mpConnect(code, true);
    alert("Room code: " + code + "\\nShare this with others to join!");
  };

  document.getElementById("joinBtn").onclick = () => {
    const name = document.getElementById("mpName").value.trim();
    const code = document.getElementById("mpRoom").value.trim();
    if (!name) return alert("Enter your name first");
    if (!code) return alert("Enter room code");
    mpConnect(code, false);
  };

  document.getElementById("leaveBtn").onclick = mpLeave;

  window.addEventListener('load', () => {
    const info = loadConnectionInfo();
    if (info.room && info.name) {
      document.getElementById("mpName").value = info.name;
      document.getElementById("mpRoom").value = info.room;
    }
  });

  // ===== Log drawer controls =====
  const drawer = document.getElementById("logDrawer");
  const toggle = document.getElementById("logToggle");
  const openBtn = document.getElementById("logOpenBtn");

  function setDrawer(open){
    drawer.classList.toggle("open", open);
    toggle.textContent = open ? "‚¨á" : "‚¨Ü";
    openBtn.textContent = open ? "‚¨á Log" : "‚¨Ü Log";
  }
  toggle.onclick = () => setDrawer(!drawer.classList.contains("open"));
  openBtn.onclick = () => setDrawer(!drawer.classList.contains("open"));

  // ===== Game logic (your original rules) =====
  const SUITS = ["‚ô†", "‚ô•", "‚ô¶", "‚ô£"];
  const RANKS = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
  const RANK_ORDER = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
  const rankOrder = (r) => RANK_ORDER.indexOf(r);
  const isFace = (r) => r === "J" || r === "Q" || r === "K";

  const EMOJIS = ["ü¶ä", "üêº", "üêØ", "ü¶Å", "üê∏", "üêô", "ü¶â", "ü¶Ñ", "üê≤", "üê∂", "üê±", "üêµ"];
  const SEAT_CLASSES = ["seat-bottom", "seat-left", "seat-top", "seat-right", "seat-tl", "seat-tr"];

  const state = {
    players: [],
    deck: [],
    discard: [],
    pile: [],
    currentPlayer: 0,
    mustPlayAny: false
  };

  let selected = new Set();
  const el = (id) => document.getElementById(id);

  function logLine(text, tone = "") {
    const div = document.createElement("div");
    div.className = "line";
    const timestamp = new Date().toLocaleTimeString();
    div.innerHTML = `<span class="muted">[${timestamp}]</span> ` + (tone ? `<span class="${tone}">‚óè</span> ` : "") + text;
    el("log").prepend(div);
  }

  function ensurePlayersFromServer(players) {
    while (state.players.length < players.length) {
      const idx = state.players.length;
      state.players.push({
        name: `Player ${idx + 1}`,
        emoji: EMOJIS[idx % EMOJIS.length],
        hand: [],
        tableUp: Array.from({ length: 4 }, () => null),
        tableDown: Array.from({ length: 4 }, () => null)
      });
    }
    players.forEach((p, idx) => {
      if (state.players[idx]) state.players[idx].name = p.name || `Player ${idx + 1}`;
    });
  }

  function applyRemoteState(remote) {
    if (!remote) return;
    state.players = remote.players;
    state.deck = remote.deck;
    state.discard = remote.discard;
    state.pile = remote.pile;
    state.currentPlayer = remote.currentPlayer;
    state.mustPlayAny = remote.mustPlayAny;
    selected.clear();
    render();
  }

  function resetLocalState() {
    state.deck = [];
    state.discard = [];
    state.pile = [];
    state.currentPlayer = 0;
    state.mustPlayAny = false;
    selected.clear();
  }

  function topRank() {
    return state.pile.length ? state.pile[state.pile.length - 1].rank : null;
  }

  function canPlayOnTop(rank) {
    if (state.mustPlayAny) return true;
    const top = topRank();
    if (!top) return true;
    if (rank === "10" || rank === "JOKER") return true;
    if (top === "10" || top === "JOKER") return false;
    if (isFace(rank) && !isFace(top)) return false;
    return rankOrder(rank) <= rankOrder(top);
  }

  function makeDeck() {
    const d = [];
    for (let k = 0; k < 2; k++) {
      for (const s of SUITS) {
        for (const r of RANKS) {
          d.push({ id: crypto.randomUUID(), rank: r, suit: s });
        }
      }
    }
    for (let j = 0; j < 4; j++) d.push({ id: crypto.randomUUID(), rank: "JOKER", suit: "‚òÖ" });
    for (let i = d.length - 1; i > 0; i--) {
      const k = Math.floor(Math.random() * (i + 1));
      [d[i], d[k]] = [d[k], d[i]];
    }
    return d;
  }

  function newGame() {
    if (!mpConnected) {
      logLine("Must be connected to start game", "bad");
      return;
    }

    if (mySeat !== 0) {
      logLine("Only Host (Player 1) can start", "warn");
      return;
    }

    state.deck = makeDeck();
    state.discard = [];
    state.pile = [];
    state.mustPlayAny = false;
    state.currentPlayer = 0;

    state.players.forEach(p => {
      p.hand = [];
      p.tableUp = Array.from({ length: 4 }, () => null);
      p.tableDown = Array.from({ length: 4 }, () => null);
    });

    for (let i = 0; i < 4; i++) state.players.forEach(p => p.tableDown[i] = state.deck.pop());
    for (let i = 0; i < 4; i++) state.players.forEach(p => p.tableUp[i] = state.deck.pop());
    for (let i = 0; i < 11; i++) state.players.forEach(p => p.hand.push(state.deck.pop()));

    const start = state.deck.pop();
    state.pile.push(start);
    if (start.rank === "10" || start.rank === "JOKER") {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
    }

    logLine("Game started by host", "ok");
    mpSendAction("START", state);
    render();
  }

  function isMyTurn() {
    return mySeat !== null && mySeat === state.currentPlayer;
  }

  function playSelected() {
    if (!isMyTurn()) {
      logLine("Not your turn", "warn");
      return;
    }
    if (mySeat === null) return;
    const me = state.players[mySeat];
    if (!me) return;
    if (!selected.size) return;

    const ids = Array.from(selected);
    const chosen = [];

    for (const id of ids) {
      const h = me.hand.find(c => c.id === id);
      if (h) chosen.push({ card: h, zone: "hand" });
      const upIdx = me.tableUp.findIndex(c => c && c.id === id);
      if (upIdx !== -1) chosen.push({ card: me.tableUp[upIdx], zone: "tableUp", idx: upIdx });
    }
    if (!chosen.length) return;

    const rank = chosen[0].card.rank;
    if (!chosen.every(x => x.card.rank === rank)) {
      logLine("Must play same rank", "bad");
      return;
    }
    if (!canPlayOnTop(rank)) {
      logLine("Illegal play - cannot play " + rank + " on " + topRank(), "bad");
      return;
    }

    chosen.forEach(x => {
      if (x.zone === "hand") me.hand = me.hand.filter(c => c.id !== x.card.id);
      if (x.zone === "tableUp") me.tableUp[x.idx] = null;
      state.pile.push(x.card);
    });
    selected.clear();

    if (rank === "10" || rank === "JOKER") {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
      logLine("üéâ Clear! Play again", "ok");
      mpSendAction("UPDATE", state);
      render();
      return;
    }

    const cnt = state.pile.reduce((a, c) => a + (c.rank === rank ? 1 : 0), 0);
    if (cnt >= 3) {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
      logLine("üéä Triple clear! Play again", "ok");
      mpSendAction("UPDATE", state);
      render();
      return;
    }

    state.mustPlayAny = false;
    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
    logLine("Played " + rank, "ok");
    mpSendAction("UPDATE", state);
    render();
  }

  function pickup() {
    if (!isMyTurn()) {
      logLine("Not your turn", "warn");
      return;
    }
    if (mySeat === null) return;
    const me = state.players[mySeat];
    me.hand.push(...state.pile);
    logLine("Picked up " + state.pile.length + " cards", "warn");
    state.pile = [];
    state.mustPlayAny = true;
    selected.clear();
    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
    mpSendAction("UPDATE", state);
    render();
  }

  // Drag helpers
  function isOverPile(x,y){
    const r = el("pileVisualWrap").getBoundingClientRect();
    return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
  }

  function dragStart(cardId, cardEl, pid, x, y){
    drag.active = true;
    drag.cardId = cardId;
    drag.el = cardEl;
    drag.pid = pid;
    drag.moved = false;
    drag.sx = x; drag.sy = y;
    cardEl.classList.add("dragging");
    cardEl.setPointerCapture(pid);
  }

  function dragMove(x,y){
    if(!drag.active) return;
    const dx = Math.abs(x - drag.sx);
    const dy = Math.abs(y - drag.sy);
    if(dx + dy > 6) drag.moved = true;
    el("pileVisualWrap").classList.toggle("dragOver", isOverPile(x,y));
  }

  function dragEnd(x,y){
    if(!drag.active) return;
    el("pileVisualWrap").classList.remove("dragOver");
    try{ drag.el && drag.pid && drag.el.releasePointerCapture(drag.pid); }catch{}
    if(drag.el) drag.el.classList.remove("dragging");

    if(drag.moved && isOverPile(x,y)){
      selected.clear();
      selected.add(drag.cardId);
      playSelected();
    }

    drag.active=false; drag.cardId=null; drag.el=null; drag.pid=null; drag.moved=false;
  }

  function render() {
    el("pileCount").textContent = String(state.pile.length);
    el("deckCount").textContent = String(state.deck.length);
    el("discardCount").textContent = String(state.discard.length);
    el("topValue").textContent = state.mustPlayAny ? "ANY" : (topRank() || "‚Äî");
    el("turnInfo").textContent = "Turn: " + (state.players[state.currentPlayer]?.name || "‚Äî");
    el("turnPill").textContent = (state.players[state.currentPlayer]?.name ? ("Turn: " + state.players[state.currentPlayer].name) : "‚Äî");
    el("turnHint").textContent = isMyTurn() ? "üëâ Your turn!" : "Waiting...";

    const pr = el("playersRow");
    pr.innerHTML = "";
    state.players.forEach((p, idx) => {
      const d = document.createElement("div");
      const seat = SEAT_CLASSES[idx] || "";
      d.className = `playerChip ${seat} ${idx === state.currentPlayer ? "active" : ""}`;
      d.innerHTML = `<div class="avatar"><span class="emo">${p.emoji}</span><span class="init">${idx + 1}</span></div>
                     <div><div style="font-weight:900">${p.name}</div>
                     <div class="muted" style="font-size:11px">Hand: ${p.hand.length} | Table: ${p.tableUp.filter(c => c).length}</div></div>`;
      pr.appendChild(d);
    });

    const pv = el("pileVisualWrap");
    pv.innerHTML = "";
    state.pile.slice(-6).forEach((c, i) => {
      const d = document.createElement("div");
      d.className = "c";
      d.style.position = "absolute";
      d.style.left = "50%";
      d.style.top = `${14 + i * 4}px`;
      d.style.transform = `translateX(-50%) rotate(${i * 4 - 8}deg)`;
      d.innerHTML = `<div class="corner top">${c.rank}<br>${c.suit}</div><div class="pip">${c.suit}</div><div class="corner bottom">${c.rank}<br>${c.suit}</div>`;
      pv.appendChild(d);
    });

    const handEl = el("yourHand");
    const tableEl = el("yourTable");
    handEl.innerHTML = "";
    tableEl.innerHTML = "";

    if (mySeat === null || !state.players[mySeat]) {
      handEl.innerHTML = '<div class="muted" style="padding:12px;text-align:center;">Join a room to see your cards</div>';
      return;
    }

    const me = state.players[mySeat];

    me.hand.forEach(card => {
      const d = document.createElement("div");
      d.className = "c selectable";
      const legal = canPlayOnTop(card.rank);
      if (!legal) d.classList.add("illegal");
      if (selected.has(card.id)) d.classList.add("selected");

      d.onclick = () => {
        if (!isMyTurn()) { logLine("Wait for your turn", "warn"); return; }
        if (!legal) { logLine("Cannot play " + card.rank + " on " + topRank(), "bad"); return; }

        if (selected.has(card.id)) selected.delete(card.id);
        else {
          if (selected.size) {
            const anyId = selected.values().next().value;
            const anyCard = me.hand.find(x => x.id === anyId) || me.tableUp.find(x => x && x.id === anyId);
            if (anyCard && anyCard.rank !== card.rank) { logLine("Must select same rank", "warn"); selected.clear(); }
          }
          selected.add(card.id);
        }
        render();
      };

      d.addEventListener("pointerdown", (e) => {
        if (!isMyTurn()) return;
        if (!legal) return;
        dragStart(card.id, d, e.pointerId, e.clientX, e.clientY);
      });
      d.addEventListener("pointermove", (e) => { if(!drag.active) return; dragMove(e.clientX, e.clientY); });
      d.addEventListener("pointerup", (e) => { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });
      d.addEventListener("pointercancel", (e) => { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });

      d.innerHTML = `<div class="corner top">${card.rank}<br>${card.suit}</div><div class="pip">${card.suit}</div><div class="corner bottom">${card.rank}<br>${card.suit}</div>`;
      handEl.appendChild(d);
    });

    for (let i = 0; i < 4; i++) {
      const up = me.tableUp[i];
      if (up) {
        const d = document.createElement("div");
        d.className = "c selectable";
        const legal = canPlayOnTop(up.rank);
        if (!legal) d.classList.add("illegal");
        if (selected.has(up.id)) d.classList.add("selected");

        d.onclick = () => {
          if (!isMyTurn()) { logLine("Wait for your turn", "warn"); return; }
          if (me.hand.length > 0) { logLine("Must play hand cards first", "warn"); return; }
          if (!legal) { logLine("Cannot play " + up.rank + " on " + topRank(), "bad"); return; }

          if (selected.has(up.id)) selected.delete(up.id);
          else {
            if (selected.size) {
              const anyId = selected.values().next().value;
              const anyCard = me.tableUp.find(x => x && x.id === anyId);
              if (anyCard && anyCard.rank !== up.rank) { logLine("Must select same rank", "warn"); selected.clear(); }
            }
            selected.add(up.id);
          }
          render();
        };

        d.addEventListener("pointerdown", (e) => {
          if (!isMyTurn()) return;
          if (me.hand.length > 0) return;
          if (!legal) return;
          dragStart(up.id, d, e.pointerId, e.clientX, e.clientY);
        });
        d.addEventListener("pointermove", (e) => { if(!drag.active) return; dragMove(e.clientX, e.clientY); });
        d.addEventListener("pointerup", (e) => { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });
        d.addEventListener("pointercancel", (e) => { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });

        d.innerHTML = `<div class="corner top">${up.rank}<br>${up.suit}</div><div class="pip">${up.suit}</div><div class="corner bottom">${up.rank}<br>${up.suit}</div>`;
        tableEl.appendChild(d);
      } else {
        const empty = document.createElement("div");
        empty.className = "c";
        empty.style.opacity = "0.22";
        empty.innerHTML = `<div class="pip">‚Äî</div>`;
        tableEl.appendChild(empty);
      }
    }

    el("newGame").disabled = (mySeat !== 0 || !mpConnected);
    el("playBtn").disabled = (!isMyTurn() || !mpConnected);
    el("pickupBtn").disabled = (!isMyTurn() || !mpConnected);
  }

  el("newGame").onclick = newGame;
  el("playBtn").onclick = playSelected;
  el("pickupBtn").onclick = pickup;

  logLine("Welcome to Splash! Host or join a room to start.", "ok");
  mpSetStatus("Not connected");
  render();
})();
</script>
</body>
</html>
