<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Splash</title>

  <style>
    :root{
      --bg:#0b1220;
      --table1:#12204a;
      --table2:#0c1430;
      --accent:#63b3ed;
      --danger:#ff7b72;
      --ok:#7ee787;
      --muted:rgba(230,237,247,.72);
      --shadow:0 10px 26px rgba(0,0,0,.45);

      --card-w: clamp(46px, 8.2vw, 74px);
      --card-h: calc(var(--card-w) * 1.45);

      --pile-h: 125px;
      --panel-h: 200px;
      --gap: 8px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; overflow:hidden; }
    body{
      color:#e6edf7;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(circle at top, #142046, var(--bg) 60%);
      -webkit-tap-highlight-color: transparent;
    }

    button,input{
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.16);
      color:#e6edf7;
      padding:10px 12px;
      border-radius:14px;
      font-size:14px;
      outline:none;
    }
    button{ cursor:pointer; }
    button.primary{ background:rgba(99,179,237,.22); border-color:rgba(99,179,237,.45); }
    button.danger{ background:rgba(255,123,114,.18); border-color:rgba(255,123,114,.45); }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .muted{ color:var(--muted); font-size:12px; }
    .pill{
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      font-size:12px;
      display:inline-flex;
      gap:6px;
      align-items:center;
      white-space:nowrap;
    }

    #app{ height:100%; display:flex; flex-direction:column; }

    /* ---------------- LOBBY ---------------- */
    #lobbyView{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
    }
    .lobbyCard{
      width:min(560px,100%);
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.12);
      border-radius:22px;
      box-shadow: var(--shadow);
      padding:18px;
    }
    .lobbyTop{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .lobbyTop h1{
      margin:0;
      font-size:20px;
      font-weight:900;
      letter-spacing:.2px;
    }
    .lobbyGrid{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .lobbyGrid input{ width:100%; text-transform:none; }
    #roomInput{ text-transform:uppercase; }
    .lobbyActions{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .lobbyHelp{
      margin-top:12px;
      padding-top:12px;
      border-top:1px solid rgba(255,255,255,.10);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    @media(max-width:520px){
      .lobbyGrid{ grid-template-columns:1fr; }
      .lobbyActions{ grid-template-columns:1fr; }
    }

    /* ---------------- GAME ---------------- */
    #gameView{
      height:100%;
      display:none;
      flex-direction:column;
    }

    header{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    header .left{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header .right{ margin-left:auto; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header .title{ font-weight:900; letter-spacing:.2px; white-space:nowrap; }

    main{
      flex:1;
      min-height:0;
      padding:10px;
      overflow:hidden;
      padding-bottom: calc(var(--panel-h) + 24px + env(safe-area-inset-bottom));
    }

    .table{
      height:100%;
      min-height:0;
      background: linear-gradient(180deg, var(--table1), var(--table2));
      border-radius:22px;
      box-shadow: var(--shadow);
      padding:12px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .playersRow{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:8px;
      flex:0 0 auto;
    }

    .playerChip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:16px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      min-width:0;
    }
    .playerChip.active{
      outline:2px solid var(--accent);
      box-shadow:0 0 16px rgba(99,179,237,.35);
    }
    .avatar{
      width:38px;height:38px;border-radius:50%;
      background:rgba(255,255,255,.9);
      color:#0b1220;
      display:flex;align-items:center;justify-content:center;
      font-weight:900;
      flex:0 0 auto;
      position:relative;
    }
    .avatar .emo{ font-size:18px; }
    .avatar .seat{
      position:absolute;
      bottom:-2px; right:-2px;
      background:#000;
      color:#fff;
      font-size:10px;
      padding:1px 5px;
      border-radius:999px;
    }

    .pileBox{
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      padding:10px;
      flex:0 0 auto;
      overflow:hidden;
    }
    .pileRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .pileVisual{
      width:100%;
      height:var(--pile-h);
      border-radius:16px;
      border:2px dashed rgba(255,255,255,.20);
      background:rgba(0,0,0,.18);
      margin-top:10px;
      position:relative;
      overflow:hidden;
      transition:.15s ease;
    }
    .pileVisual.dragOver{
      border-color:var(--accent);
      background:rgba(99,179,237,.14);
    }

    .zoneTitle{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      color:var(--muted);
      font-size:12px;
      flex:0 0 auto;
    }

    /* -------- Cards -------- */
    .c{
      width:var(--card-w);
      height:var(--card-h);
      border-radius:12px;
      background:#fff;
      color:#111;
      position:relative;
      box-shadow:0 6px 18px rgba(0,0,0,.45);
      user-select:none;
      touch-action:none;
      transition:.12s ease;
    }
    .c.illegal{ opacity:.55; }
    .c.selected{ outline:3px solid var(--accent); transform:translateY(-3px); }
    .corner{
      position:absolute;
      font-weight:900;
      font-size:12px;
      line-height:1;
    }
    .corner.top{ top:6px; left:6px; }
    .corner.bottom{ bottom:6px; right:6px; transform:rotate(180deg); }
    .pip{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      font-size:28px;
    }

    /* -------- Grouped hand stacks: 5 per row -------- */
    .handStacks{
      flex:1 1 auto;
      min-height:0;
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap:8px;
      justify-items:center;
      align-content:start;
      overflow:hidden;
    }
    .cardStack{
      width:var(--card-w);
      height:var(--card-h);
      position:relative;
    }
    .cardStack .c{ position:absolute; top:0; left:0; }
    .stackGhost{
      opacity:.18;
      filter:saturate(.9);
    }
    .stackGhost.g1{ transform: translate(7px, -7px); }
    .stackGhost.g2{ transform: translate(14px, -14px); }
    .stackCount{
      position:absolute;
      top:-6px; right:-6px;
      background:rgba(0,0,0,.82);
      border:1px solid rgba(255,255,255,.18);
      color:#fff;
      font-size:11px;
      padding:2px 7px;
      border-radius:999px;
      font-weight:900;
    }

    /* -------- Table cards: 5 columns, first 4 used -------- */
    .tableCards{
      flex:0 0 auto;
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap:8px;
      justify-items:center;
      overflow:hidden;
    }

    /* -------- Bottom Panel -------- */
    .panel{
      position:fixed;
      left:10px;
      right:10px;
      bottom: calc(10px + env(safe-area-inset-bottom));
      height:var(--panel-h);
      background:rgba(15,20,40,.96);
      border:1px solid rgba(255,255,255,.14);
      border-radius:22px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      z-index:1000;
      backdrop-filter: blur(10px);
    }
    .panel .row{ display:flex; gap:10px; }
    .panel button{ flex:1; }

    .logWrap{
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      background:rgba(0,0,0,.22);
      display:flex;
      flex-direction:column;
    }
    .logHead{
      flex:0 0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .logBody{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      padding:8px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
    }
    .logLine{
      padding:2px 0;
      border-bottom:1px dashed rgba(255,255,255,.08);
    }
    .logLine:last-child{ border-bottom:none; }

    /* -------- Snap animation clone -------- */
    .snapClone{
      position:fixed;
      z-index:5000;
      pointer-events:none;
      transition: transform .22s ease, opacity .22s ease;
      transform-origin:center center;
    }
  </style>
</head>

<body>
<div id="app">

  <!-- LOBBY -->
  <section id="lobbyView">
    <div class="lobbyCard">
      <div class="lobbyTop">
        <div>
          <h1>üÉè Splash</h1>
          <div class="muted">Host a room or join your family‚Äôs room.</div>
        </div>
        <span class="pill" id="lobbyStatus">Not connected</span>
      </div>

      <div class="lobbyGrid">
        <div>
          <div class="muted" style="margin:0 0 6px;">Your name</div>
          <input id="nameInput" placeholder="Name" />
        </div>
        <div>
          <div class="muted" style="margin:0 0 6px;">Room code</div>
          <input id="roomInput" placeholder="ROOM" />
        </div>
      </div>

      <div class="lobbyActions">
        <button id="hostBtn" class="primary">Host</button>
        <button id="joinBtn" class="primary">Join</button>
      </div>

      <div class="lobbyHelp">
        <div class="muted">Tip: Share the room code with everyone.</div>
        <div class="muted">In-game: tap a stack to select that rank, drag it to the pile to play (snap animation).</div>
      </div>
    </div>
  </section>

  <!-- GAME -->
  <section id="gameView">
    <header>
      <div class="left">
        <div class="title">üÉè Splash</div>
        <span class="pill" id="roomPill">ROOM: ‚Äî</span>
        <span class="pill" id="turnInfo">Turn: ‚Äî</span>
      </div>
      <div class="right">
        <button id="newGame" class="primary">New Game</button>
        <button id="leaveBtn" class="danger">Leave</button>
      </div>
    </header>

    <main>
      <div class="table">
        <div class="playersRow" id="playersRow"></div>

        <div class="pileBox">
          <div class="pileRow">
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
              <span class="pill">Deck: <span id="deckCount">‚Äî</span></span>
              <span class="pill">Discard: <span id="discardCount">‚Äî</span></span>
              <span class="pill">Pile: <span id="pileCount">‚Äî</span></span>
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
              <span class="muted">Top:</span>
              <span class="pill" id="topValue">‚Äî</span>
            </div>
          </div>
          <div class="pileVisual" id="pileVisual"></div>
          <div class="muted" style="margin-top:8px;">Tap a stack to select. Drag it onto the pile to play.</div>
        </div>

        <div class="zoneTitle">
          <span>Your hand (grouped)</span>
          <span class="muted" id="turnHint">‚Äî</span>
        </div>
        <div id="handStacks" class="handStacks"></div>

        <div class="zoneTitle">
          <span>Your table cards</span>
          <span class="muted">Play hand first</span>
        </div>
        <div id="yourTable" class="tableCards"></div>
      </div>
    </main>

    <div class="panel">
      <div class="row">
        <button id="playBtn" class="primary">Play Selected</button>
        <button id="pickupBtn" class="danger">Pick Up Pile</button>
      </div>
      <div class="row">
        <button id="clearSelBtn">Clear Selection</button>
        <span class="pill" id="selPill" style="flex:1; justify-content:center;">Selected: ‚Äî</span>
      </div>

      <div class="logWrap">
        <div class="logHead">
          <div style="font-weight:900;">Game Log</div>
          <span class="muted">Latest on top</span>
        </div>
        <div id="log" class="logBody"></div>
      </div>
    </div>

  </section>

</div>

<script>
(() => {
  const WS_BASE = "wss://splash-multiplayer.azimaymen.workers.dev";
  const mpClientId = crypto.randomUUID();

  // views
  const lobbyView = document.getElementById("lobbyView");
  const gameView = document.getElementById("gameView");

  // lobby controls
  const nameInput = document.getElementById("nameInput");
  const roomInput = document.getElementById("roomInput");
  const lobbyStatus = document.getElementById("lobbyStatus");

  // game controls
  const roomPill = document.getElementById("roomPill");
  const turnInfo = document.getElementById("turnInfo");
  const turnHint = document.getElementById("turnHint");
  const playersRow = document.getElementById("playersRow");
  const pileVisual = document.getElementById("pileVisual");
  const handStacks = document.getElementById("handStacks");
  const yourTable = document.getElementById("yourTable");
  const logEl = document.getElementById("log");

  const deckCount = document.getElementById("deckCount");
  const discardCount = document.getElementById("discardCount");
  const pileCount = document.getElementById("pileCount");
  const topValue = document.getElementById("topValue");

  const playBtn = document.getElementById("playBtn");
  const pickupBtn = document.getElementById("pickupBtn");
  const newGameBtn = document.getElementById("newGame");
  const leaveBtn = document.getElementById("leaveBtn");
  const clearSelBtn = document.getElementById("clearSelBtn");
  const selPill = document.getElementById("selPill");

  // multiplayer state
  let mpWs = null;
  let mpRoom = null;
  let mpConnected = false;
  let mySeat = null;
  let reconnectAttempts = 0;
  let reconnectTimer = null;
  const MAX_RECONNECT_ATTEMPTS = 5;

  // drag state (stack dragging)
  const drag = { active:false, ids:null, el:null, pid:null, moved:false, sx:0, sy:0 };

  // game constants
  const SUITS = ["‚ô†", "‚ô•", "‚ô¶", "‚ô£"];
  const RANKS = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
  const RANK_ORDER = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
  const rankOrder = (r) => RANK_ORDER.indexOf(r);
  const isFace = (r) => r === "J" || r === "Q" || r === "K";

  const EMOJIS = ["ü¶ä", "üêº", "üêØ", "ü¶Å", "üê∏", "üêô", "ü¶â", "ü¶Ñ", "üê≤", "üê∂", "üê±", "üêµ"];

  const state = {
    players: [],
    deck: [],
    discard: [],
    pile: [],
    currentPlayer: 0,
    mustPlayAny: false
  };

  let selected = new Set(); // card ids

  function showLobby(){
    gameView.style.display = "none";
    lobbyView.style.display = "flex";
  }
  function showGame(){
    lobbyView.style.display = "none";
    gameView.style.display = "flex";
  }

  function setLobbyStatus(text, ok=false){
    lobbyStatus.textContent = text;
    lobbyStatus.style.borderColor = ok ? "rgba(126,231,135,.5)" : "rgba(255,255,255,.14)";
  }

  function saveConnectionInfo(room, name){
    localStorage.setItem("splash_room", room);
    localStorage.setItem("splash_name", name);
  }
  function loadConnectionInfo(){
    return {
      room: localStorage.getItem("splash_room"),
      name: localStorage.getItem("splash_name")
    };
  }
  function clearConnectionInfo(){
    localStorage.removeItem("splash_room");
    localStorage.removeItem("splash_name");
  }

  function logLine(text, tone=""){
    const div = document.createElement("div");
    div.className = "logLine";
    const ts = new Date().toLocaleTimeString();
    div.innerHTML = `<span class="muted">[${ts}]</span> ${tone ? `<span class="${tone}">‚óè</span> ` : ""}${text}`;
    logEl.prepend(div);
  }

  // ---------- WebSocket ----------
  function mpConnect(room){
    mpRoom = room.toUpperCase();
    roomPill.textContent = `ROOM: ${mpRoom}`;
    setLobbyStatus(`Connecting to ${mpRoom}‚Ä¶`, false);

    mpWs = new WebSocket(`${WS_BASE}?room=${mpRoom}`);

    const nm = (nameInput.value || "Player").trim();
    saveConnectionInfo(mpRoom, nm);

    mpWs.onopen = () => {
      mpConnected = true;
      reconnectAttempts = 0;
      setLobbyStatus(`Connected: ${mpRoom}`, true);

      mpWs.send(JSON.stringify({ type:"join", id: mpClientId, name: nm }));
      showGame();
      logLine(`Connected to room ${mpRoom}`, "ok");
    };

    mpWs.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "players") {
        mySeat = msg.players.findIndex(p => p.id === mpClientId);
        ensurePlayersFromServer(msg.players);
        render();
      }

      if (msg.type === "state") {
        applyRemoteState(msg.payload?.state);
      }

      if (msg.type === "pong") {}
      if (msg.type === "reset") {
        logLine("Game reset", "warn");
        resetLocalState();
        render();
      }
    };

    mpWs.onclose = () => {
      mpConnected = false;
      setLobbyStatus("Disconnected", false);
      handleReconnect(room);
    };

    mpWs.onerror = () => {
      mpConnected = false;
      setLobbyStatus("Connection error", false);
    };

    setInterval(() => {
      if (mpWs && mpWs.readyState === WebSocket.OPEN) {
        mpWs.send(JSON.stringify({ type:"ping" }));
      }
    }, 30000);
  }

  function handleReconnect(room){
    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      logLine("Failed to reconnect", "bad");
      return;
    }
    reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
    setLobbyStatus(`Reconnecting‚Ä¶ (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, false);
    reconnectTimer = setTimeout(() => mpConnect(room), delay);
  }

  // server-authoritative action sender
  function mpSendAction(actionType, nextState){
    if (!mpWs || mpWs.readyState !== WebSocket.OPEN) {
      logLine("Cannot sync - not connected", "warn");
      return;
    }
    mpWs.send(JSON.stringify({
      type: "action",
      action: { type: actionType, state: JSON.parse(JSON.stringify(nextState)) }
    }));
  }

  function mpLeave(){
    if (reconnectTimer) clearTimeout(reconnectTimer);
    if (mpWs) mpWs.close();
    mpWs = null;
    mpConnected = false;
    mpRoom = null;
    mySeat = null;
    clearConnectionInfo();
    selected.clear();
    resetLocalState();
    render();
    showLobby();
    setLobbyStatus("Not connected", false);
    logLine("Left room", "warn");
  }

  // lobby buttons
  document.getElementById("hostBtn").onclick = () => {
    const nm = (nameInput.value || "").trim();
    if (!nm) return alert("Enter your name");
    const code = Math.random().toString(36).slice(2, 8).toUpperCase();
    roomInput.value = code;
    mpConnect(code);
    alert("Room code: " + code + "\nShare this with others to join!");
  };
  document.getElementById("joinBtn").onclick = () => {
    const nm = (nameInput.value || "").trim();
    const code = (roomInput.value || "").trim();
    if (!nm) return alert("Enter your name");
    if (!code) return alert("Enter room code");
    mpConnect(code);
  };

  // game buttons
  leaveBtn.onclick = mpLeave;
  clearSelBtn.onclick = () => { selected.clear(); renderSelectionPill(); render(); };
  playBtn.onclick = () => { animateSelectedToPile(); playSelected(); };
  pickupBtn.onclick = pickup;
  newGameBtn.onclick = newGame;

  // restore saved info
  window.addEventListener("load", () => {
    const info = loadConnectionInfo();
    if (info.name) nameInput.value = info.name;
    if (info.room) roomInput.value = info.room;
    showLobby();
    setLobbyStatus("Not connected", false);
    logLine("Welcome! Host or join a room.", "ok");
  });

  // ---------- Game model helpers ----------
  function ensurePlayersFromServer(players) {
    while (state.players.length < players.length) {
      const idx = state.players.length;
      state.players.push({
        name: `Player ${idx + 1}`,
        emoji: EMOJIS[idx % EMOJIS.length],
        hand: [],
        tableUp: Array.from({ length: 4 }, () => null),
        tableDown: Array.from({ length: 4 }, () => null)
      });
    }
    players.forEach((p, idx) => {
      if (state.players[idx]) state.players[idx].name = p.name || `Player ${idx + 1}`;
    });
  }

  function applyRemoteState(remote) {
    if (!remote) return;
    state.players = remote.players;
    state.deck = remote.deck;
    state.discard = remote.discard;
    state.pile = remote.pile;
    state.currentPlayer = remote.currentPlayer;
    state.mustPlayAny = remote.mustPlayAny;
    selected.clear();
    renderSelectionPill();
    render();
  }

  function resetLocalState() {
    state.deck = [];
    state.discard = [];
    state.pile = [];
    state.currentPlayer = 0;
    state.mustPlayAny = false;
    state.players.forEach(p => {
      p.hand = [];
      p.tableUp = Array.from({ length: 4 }, () => null);
      p.tableDown = Array.from({ length: 4 }, () => null);
    });
  }

  function topRank() {
    return state.pile.length ? state.pile[state.pile.length - 1].rank : null;
  }

  function canPlayOnTop(rank) {
    if (state.mustPlayAny) return true;
    const top = topRank();
    if (!top) return true;
    if (rank === "10" || rank === "JOKER") return true;
    if (top === "10" || top === "JOKER") return false;
    if (isFace(rank) && !isFace(top)) return false;
    return rankOrder(rank) <= rankOrder(top);
  }

  function makeDeck() {
    const d = [];
    for (let k = 0; k < 2; k++) {
      for (const s of SUITS) {
        for (const r of RANKS) {
          d.push({ id: crypto.randomUUID(), rank: r, suit: s });
        }
      }
    }
    for (let j = 0; j < 4; j++) d.push({ id: crypto.randomUUID(), rank: "JOKER", suit: "‚òÖ" });
    for (let i = d.length - 1; i > 0; i--) {
      const k = Math.floor(Math.random() * (i + 1));
      [d[i], d[k]] = [d[k], d[i]];
    }
    return d;
  }

  function isMyTurn() {
    return mySeat !== null && mySeat === state.currentPlayer;
  }

  function newGame() {
    if (!mpConnected) { logLine("Must be connected to start", "bad"); return; }
    if (mySeat !== 0) { logLine("Only Host (Player 1) can start", "warn"); return; }

    state.deck = makeDeck();
    state.discard = [];
    state.pile = [];
    state.mustPlayAny = false;
    state.currentPlayer = 0;

    state.players.forEach(p => {
      p.hand = [];
      p.tableUp = Array.from({ length: 4 }, () => null);
      p.tableDown = Array.from({ length: 4 }, () => null);
    });

    for (let i = 0; i < 4; i++) state.players.forEach(p => p.tableDown[i] = state.deck.pop());
    for (let i = 0; i < 4; i++) state.players.forEach(p => p.tableUp[i] = state.deck.pop());
    for (let i = 0; i < 11; i++) state.players.forEach(p => p.hand.push(state.deck.pop()));

    const start = state.deck.pop();
    state.pile.push(start);
    if (start.rank === "10" || start.rank === "JOKER") {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
    }

    selected.clear();
    renderSelectionPill();
    logLine("Game started by host", "ok");
    mpSendAction("START", state);
    render();
  }

  function playSelected() {
    if (!isMyTurn()) { logLine("Not your turn", "warn"); return; }
    if (mySeat === null) return;
    const me = state.players[mySeat];
    if (!me) return;
    if (!selected.size) return;

    const ids = Array.from(selected);
    const chosen = [];

    for (const id of ids) {
      const h = me.hand.find(c => c.id === id);
      if (h) chosen.push({ card: h, zone: "hand" });
      const upIdx = me.tableUp.findIndex(c => c && c.id === id);
      if (upIdx !== -1) chosen.push({ card: me.tableUp[upIdx], zone: "tableUp", idx: upIdx });
    }
    if (!chosen.length) return;

    const rank = chosen[0].card.rank;
    if (!chosen.every(x => x.card.rank === rank)) {
      logLine("Must play same rank", "bad");
      return;
    }
    if (!canPlayOnTop(rank)) {
      logLine("Illegal play - cannot play " + rank + " on " + topRank(), "bad");
      return;
    }

    chosen.forEach(x => {
      if (x.zone === "hand") me.hand = me.hand.filter(c => c.id !== x.card.id);
      if (x.zone === "tableUp") me.tableUp[x.idx] = null;
      state.pile.push(x.card);
    });
    selected.clear();
    renderSelectionPill();

    if (rank === "10" || rank === "JOKER") {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
      logLine("üéâ Clear! Play again", "ok");
      mpSendAction("UPDATE", state);
      render();
      return;
    }

    const cnt = state.pile.reduce((a, c) => a + (c.rank === rank ? 1 : 0), 0);
    if (cnt >= 3) {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
      logLine("üéä Triple clear! Play again", "ok");
      mpSendAction("UPDATE", state);
      render();
      return;
    }

    state.mustPlayAny = false;
    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
    logLine("Played " + rank, "ok");
    mpSendAction("UPDATE", state);
    render();
  }

  function pickup() {
    if (!isMyTurn()) { logLine("Not your turn", "warn"); return; }
    if (mySeat === null) return;
    const me = state.players[mySeat];
    me.hand.push(...state.pile);
    logLine("Picked up " + state.pile.length + " cards", "warn");
    state.pile = [];
    state.mustPlayAny = true;
    selected.clear();
    renderSelectionPill();
    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
    mpSendAction("UPDATE", state);
    render();
  }

  // ---------- Grouping ----------
  function groupByRank(cards){
    const m = new Map();
    for (const c of cards){
      if (!m.has(c.rank)) m.set(c.rank, []);
      m.get(c.rank).push(c);
    }
    const ranks = Array.from(m.keys()).sort((a,b) => {
      if (a === "JOKER" && b !== "JOKER") return 1;
      if (b === "JOKER" && a !== "JOKER") return -1;
      return RANK_ORDER.indexOf(a) - RANK_ORDER.indexOf(b);
    });
    return ranks.map(r => ({ rank:r, cards:m.get(r) }));
  }

  function renderSelectionPill(){
    if (!selected.size) { selPill.textContent = "Selected: ‚Äî"; return; }
    if (mySeat === null || !state.players[mySeat]) { selPill.textContent = `Selected: ${selected.size}`; return; }
    const me = state.players[mySeat];
    const anyId = selected.values().next().value;
    const anyCard = me.hand.find(x => x.id === anyId) || me.tableUp.find(x => x && x.id === anyId);
    selPill.textContent = anyCard ? `Selected: ${anyCard.rank} √ó ${selected.size}` : `Selected: ${selected.size}`;
  }

  // ---------- Snap animation ----------
  function animateElementToPile(fromEl){
    if (!fromEl) return;
    const from = fromEl.getBoundingClientRect();
    const to = pileVisual.getBoundingClientRect();

    const clone = fromEl.cloneNode(true);
    clone.classList.add("snapClone");
    document.body.appendChild(clone);

    clone.style.left = from.left + "px";
    clone.style.top = from.top + "px";
    clone.style.width = from.width + "px";
    clone.style.height = from.height + "px";

    const tx = (to.left + to.width/2) - (from.left + from.width/2);
    const ty = (to.top + to.height/2) - (from.top + from.height/2);

    requestAnimationFrame(() => {
      clone.style.transform = `translate(${tx}px, ${ty}px) scale(.7)`;
      clone.style.opacity = "0";
    });

    setTimeout(() => clone.remove(), 240);
  }

  function animateSelectedToPile(){
    // prefer stack element (hand) if exists
    const stack = handStacks.querySelector(".c.selected")?.parentElement; // cardStack container
    if (stack) { animateElementToPile(stack); return; }
    // else try table card selected
    const card = yourTable.querySelector(".c.selected");
    if (card) animateElementToPile(card);
  }

  // ---------- Drag to pile ----------
  function isOverPile(x,y){
    const r = pileVisual.getBoundingClientRect();
    return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
  }
  function dragStart(ids, el, pid, x, y){
    drag.active = true;
    drag.ids = ids;
    drag.el = el;
    drag.pid = pid;
    drag.moved = false;
    drag.sx = x; drag.sy = y;
    el.setPointerCapture(pid);
  }
  function dragMove(x,y){
    if(!drag.active) return;
    const dx = Math.abs(x - drag.sx);
    const dy = Math.abs(y - drag.sy);
    if (dx + dy > 6) drag.moved = true;
    pileVisual.classList.toggle("dragOver", isOverPile(x,y));
  }
  function dragEnd(x,y){
    if(!drag.active) return;
    pileVisual.classList.remove("dragOver");
    try{ drag.el.releasePointerCapture(drag.pid); }catch{}
    if(drag.moved && isOverPile(x,y)){
      // snap animation
      animateElementToPile(drag.el);
      selected.clear();
      drag.ids.forEach(id => selected.add(id));
      renderSelectionPill();
      playSelected();
    }
    drag.active=false; drag.ids=null; drag.el=null; drag.pid=null; drag.moved=false;
  }

  // ---------- Rendering ----------
  function cardHTML(c){
    return `<div class="corner top">${c.rank}<br>${c.suit}</div>
            <div class="pip">${c.suit}</div>
            <div class="corner bottom">${c.rank}<br>${c.suit}</div>`;
  }

  function render(){
    // counters & turn info
    deckCount.textContent = String(state.deck.length);
    discardCount.textContent = String(state.discard.length);
    pileCount.textContent = String(state.pile.length);
    topValue.textContent = state.mustPlayAny ? "ANY" : (topRank() || "‚Äî");
    turnInfo.textContent = "Turn: " + (state.players[state.currentPlayer]?.name || "‚Äî");
    turnHint.textContent = isMyTurn() ? "üëâ Your turn!" : "Waiting‚Ä¶";

    // players
    playersRow.innerHTML = "";
    state.players.forEach((p, idx) => {
      const d = document.createElement("div");
      d.className = "playerChip" + (idx === state.currentPlayer ? " active" : "");
      d.innerHTML = `
        <div class="avatar"><span class="emo">${p.emoji}</span><span class="seat">${idx+1}</span></div>
        <div style="min-width:0">
          <div style="font-weight:900; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${p.name}</div>
          <div class="muted" style="font-size:11px">Hand: ${p.hand.length} | Table: ${p.tableUp.filter(c => c).length}</div>
        </div>`;
      playersRow.appendChild(d);
    });

    // pile visual last 6
    pileVisual.innerHTML = "";
    state.pile.slice(-6).forEach((c, i) => {
      const d = document.createElement("div");
      d.className = "c";
      d.style.position = "absolute";
      d.style.left = "50%";
      d.style.top = `${14 + i * 4}px`;
      d.style.transform = `translateX(-50%) rotate(${i * 4 - 8}deg)`;
      d.innerHTML = cardHTML(c);
      pileVisual.appendChild(d);
    });

    // hand + table
    handStacks.innerHTML = "";
    yourTable.innerHTML = "";

    if (mySeat === null || !state.players[mySeat]) {
      handStacks.innerHTML = '<div class="muted" style="padding:10px;text-align:center;">Join a room to see your cards</div>';
      renderSelectionPill();
      return;
    }

    const me = state.players[mySeat];

    // grouped hand stacks
    const groups = groupByRank(me.hand);
    groups.forEach(g => {
      const ids = g.cards.map(c => c.id);
      const top = g.cards[g.cards.length - 1];
      const legal = true; // allow select; legality handled on play

      const stack = document.createElement("div");
      stack.className = "cardStack";

      if (g.cards.length >= 2){
        const ghost1 = document.createElement("div");
        ghost1.className = "c stackGhost g1";
        ghost1.innerHTML = cardHTML(top);
        stack.appendChild(ghost1);
      }
      if (g.cards.length >= 3){
        const ghost2 = document.createElement("div");
        ghost2.className = "c stackGhost g2";
        ghost2.innerHTML = cardHTML(top);
        stack.appendChild(ghost2);
      }

      const card = document.createElement("div");
      card.className = "c";
      card.dataset.rank = g.rank;
      card.innerHTML = cardHTML(top);

      const selectedThisRank = ids.some(id => selected.has(id));
      if (selectedThisRank) card.classList.add("selected");
      if (!canPlayOnTop(g.rank)) card.classList.add("illegal");

      stack.appendChild(card);

      if (g.cards.length > 1){
        const badge = document.createElement("div");
        badge.className = "stackCount";
        badge.textContent = g.cards.length;
        stack.appendChild(badge);
      }

      // tap stack: toggle select whole rank (one rank at a time)
      stack.onclick = () => {
        if (!isMyTurn()) { logLine("Wait for your turn", "warn"); return; }
        if (!canPlayOnTop(g.rank)) { logLine("Cannot play " + g.rank + " on " + topRank(), "bad"); return; }

        const anySelected = ids.some(id => selected.has(id));
        selected.clear();
        if (!anySelected) ids.forEach(id => selected.add(id));
        renderSelectionPill();
        render();
      };

      // drag stack to pile
      stack.addEventListener("pointerdown", (e) => {
        if (!isMyTurn()) return;
        if (!canPlayOnTop(g.rank)) return;
        selected.clear();
        ids.forEach(id => selected.add(id));
        renderSelectionPill();
        dragStart(ids, stack, e.pointerId, e.clientX, e.clientY);
      });
      stack.addEventListener("pointermove", (e) => { if(!drag.active) return; dragMove(e.clientX, e.clientY); });
      stack.addEventListener("pointerup",   (e) => { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });
      stack.addEventListener("pointercancel",(e)=> { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });

      handStacks.appendChild(stack);
    });

    // tableUp cards (must play hand first)
    for (let i = 0; i < 4; i++){
      const up = me.tableUp[i];
      if (up){
        const d = document.createElement("div");
        d.className = "c";
        if (!canPlayOnTop(up.rank)) d.classList.add("illegal");
        if (selected.has(up.id)) d.classList.add("selected");
        d.dataset.id = up.id;
        d.innerHTML = cardHTML(up);

        d.onclick = () => {
          if (!isMyTurn()) { logLine("Wait for your turn", "warn"); return; }
          if (me.hand.length > 0) { logLine("Must play hand first", "warn"); return; }
          if (!canPlayOnTop(up.rank)) { logLine("Cannot play " + up.rank + " on " + topRank(), "bad"); return; }

          selected.clear();
          selected.add(up.id);
          renderSelectionPill();
          render();
        };

        d.addEventListener("pointerdown", (e) => {
          if (!isMyTurn()) return;
          if (me.hand.length > 0) return;
          if (!canPlayOnTop(up.rank)) return;
          selected.clear();
          selected.add(up.id);
          renderSelectionPill();
          dragStart([up.id], d, e.pointerId, e.clientX, e.clientY);
        });
        d.addEventListener("pointermove", (e) => { if(!drag.active) return; dragMove(e.clientX, e.clientY); });
        d.addEventListener("pointerup",   (e) => { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });
        d.addEventListener("pointercancel",(e)=> { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });

        yourTable.appendChild(d);
      } else {
        const empty = document.createElement("div");
        empty.className = "c";
        empty.style.opacity = "0.18";
        empty.innerHTML = `<div class="pip">‚Äî</div>`;
        yourTable.appendChild(empty);
      }
    }
    // filler to keep 5 columns stable
    const filler = document.createElement("div");
    filler.style.width = "var(--card-w)";
    filler.style.height = "var(--card-h)";
    filler.style.opacity = "0";
    yourTable.appendChild(filler);

    // buttons
    newGameBtn.disabled = (mySeat !== 0 || !mpConnected);
    playBtn.disabled = (!isMyTurn() || !mpConnected || !selected.size);
    pickupBtn.disabled = (!isMyTurn() || !mpConnected);

    renderSelectionPill();
  }

})();
</script>
</body>
</html>
