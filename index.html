<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Splash</title>

  <style>
    :root{
      --bg:#0b1220;
      --card-w: clamp(46px, 8.2vw, 74px);
      --card-h: calc(var(--card-w) * 1.45);
      --accent:#63b3ed;
      --danger:#ff7b72;
      --ok:#7ee787;
      --muted:rgba(230,237,247,.72);
      --shadow:0 12px 30px rgba(0,0,0,.45);
      --panel:rgba(255,255,255,.05);
      --border:rgba(255,255,255,.12);
      --table1:#12204a;
      --table2:#0c1430;
      --gap:8px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; overflow:hidden; }
    body{
      color:#e6edf7;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(circle at top, #142046, var(--bg) 62%);
      -webkit-tap-highlight-color: transparent;
    }

    button,input{
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.16);
      color:#e6edf7;
      padding:10px 12px;
      border-radius:14px;
      font-size:14px;
      outline:none;
    }
    button{ cursor:pointer; }
    button.primary{ background:rgba(99,179,237,.22); border-color:rgba(99,179,237,.45); }
    button.danger{ background:rgba(255,123,114,.18); border-color:rgba(255,123,114,.45); }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .muted{ color:var(--muted); font-size:12px; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:5px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      font-size:12px;
      white-space:nowrap;
    }

    /* App shell */
    #app{ height:100%; display:flex; flex-direction:column; }
    .view{ height:100%; display:flex; flex-direction:column; }

    /* LOBBY */
    #lobbyView{
      padding:18px 14px calc(18px + env(safe-area-inset-bottom));
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .lobbyCard{
      width:min(520px, 100%);
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.12);
      border-radius:22px;
      box-shadow:var(--shadow);
      padding:18px;
    }
    .lobbyTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:12px;
    }
    .brand{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .brand h1{
      margin:0;
      font-size:18px;
      font-weight:900;
      letter-spacing:.2px;
    }
    .brand .muted{ font-size:12px; }
    .lobbyGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .lobbyGrid input{ width:100%; }
    .lobbyActions{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:12px;
    }
    .lobbyFoot{
      margin-top:12px;
      padding-top:12px;
      border-top:1px solid rgba(255,255,255,.10);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .roomHint{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    @media (max-width: 520px){
      .lobbyGrid{ grid-template-columns: 1fr; }
      .lobbyActions{ grid-template-columns: 1fr; }
    }

    /* GAME */
    #gameView{ display:none; }
    header{
      flex:0 0 auto;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    header .left{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    header .right{
      margin-left:auto;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    header .title{
      font-weight:900;
      letter-spacing:.2px;
      font-size:14px;
      white-space:nowrap;
    }

    main{
      flex:1 1 auto;
      min-height:0;
      padding:10px 10px calc(10px + env(safe-area-inset-bottom));
      overflow:hidden;
    }

    .grid{
      height:100%;
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    @media (min-width: 1200px){
      .grid{ grid-template-columns: 1fr 380px; }
    }

    .table{
      height:100%;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:10px;
      background: linear-gradient(180deg, var(--table1), var(--table2));
      border-radius:22px;
      padding:12px;
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    .playersRow{
      flex:0 0 auto;
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:8px;
    }
    @media (min-width: 900px){
      .playersRow{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
    }

    .playerChip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:16px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      min-width:0;
    }
    .playerChip.active{
      outline:2px solid var(--accent);
      box-shadow:0 0 16px rgba(99,179,237,.35);
    }
    .avatar{
      width:38px; height:38px;
      border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      background:rgba(255,255,255,.9);
      color:#0b1220;
      font-weight:900;
      flex:0 0 auto;
      position:relative;
    }
    .avatar .emo{ font-size:18px; }
    .avatar .seat{
      position:absolute;
      bottom:-2px; right:-2px;
      background:#000;
      color:#fff;
      font-size:10px;
      padding:1px 5px;
      border-radius:999px;
    }

    .pileBox{
      flex:0 0 auto;
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      padding:10px;
      overflow:hidden;
    }
    .pileRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:space-between;
      align-items:center;
    }
    .pileVisual{
      width:100%;
      height:130px;
      border-radius:16px;
      border:2px dashed rgba(255,255,255,.20);
      background:rgba(0,0,0,.18);
      margin-top:10px;
      position:relative;
      overflow:hidden;
      transition:.15s ease;
    }
    .pileVisual.dragOver{
      border-color:var(--accent);
      background:rgba(99,179,237,.14);
    }

    .zoneTitle{
      flex:0 0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-top:2px;
    }

    /* Cards */
    .c{
      width:var(--card-w);
      height:var(--card-h);
      border-radius:12px;
      background:#fff;
      color:#111;
      position:relative;
      box-shadow:0 6px 18px rgba(0,0,0,.45);
      user-select:none;
      touch-action:none;
      transition:.12s ease;
    }
    .c.illegal{ opacity:.55; }
    .c.selected{ outline:3px solid var(--accent); transform:translateY(-3px); }
    .c.dragging{ outline:3px solid rgba(99,179,237,.55); transform:scale(1.03); }

    .corner{
      position:absolute;
      font-weight:900;
      font-size:12px;
      line-height:1;
    }
    .corner.top{ top:6px; left:6px; }
    .corner.bottom{ bottom:6px; right:6px; transform:rotate(180deg); }
    .pip{
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-50%);
      font-size:30px;
    }
    @media (max-width: 600px){
      .corner{ font-size:11px; }
      .pip{ font-size:24px; }
    }

    /* ‚úÖ Hand grouped by rank into stacks ‚Äì 5 stacks per row */
    .handStacks{
      flex:1 1 auto;
      min-height:0;
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap:8px;
      overflow:hidden;
      justify-items:center;
      align-content:start;
      padding-bottom:2px;
    }

    .cardStack{
      width:var(--card-w);
      height:var(--card-h);
      position:relative;
    }
    .cardStack .c{ position:absolute; top:0; left:0; }
    .stackGhost{
      opacity:.20;
      filter:saturate(.9);
    }
    .stackGhost.g1{ transform: translate(7px, -7px); }
    .stackGhost.g2{ transform: translate(14px, -14px); }
    .stackCount{
      position:absolute;
      top:-8px; right:-8px;
      background:rgba(0,0,0,.8);
      border:1px solid rgba(255,255,255,.18);
      color:#fff;
      font-size:11px;
      padding:2px 7px;
      border-radius:999px;
      font-weight:900;
    }

    /* Table cards: 5 per row too (only 4 used) */
    .tableCards{
      flex:0 0 auto;
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap:8px;
      justify-items:center;
      overflow:hidden;
    }

    /* Right panel / controls */
    .panel{
      height:100%;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:10px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.10);
      border-radius:22px;
      padding:12px;
      overflow:hidden;
    }

    .actionRow{
      display:flex;
      gap:10px;
    }
    .actionRow button{ flex:1; }

    .logWrap{
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      background:rgba(0,0,0,.22);
      display:flex;
      flex-direction:column;
    }
    .logHead{
      flex:0 0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .logBody{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      padding:8px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
    }
    .logLine{
      padding:2px 0;
      border-bottom:1px dashed rgba(255,255,255,.08);
    }
    .logLine:last-child{ border-bottom:none; }

    /* Mobile: keep panel as bottom bar, but still no scrolling */
    @media (max-width: 900px){
      .grid{ grid-template-columns: 1fr; }
      .panel{
        position:fixed;
        left:10px;
        right:10px;
        bottom: calc(10px + env(safe-area-inset-bottom));
        height: 170px;
        z-index:1000;
        backdrop-filter: blur(10px);
      }
      main{ padding-bottom: 190px; }
      .logWrap{ display:none; } /* log still available via button -> overlay */
    }

    /* Mobile log overlay */
    #logOverlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      z-index:5000;
      padding:14px;
    }
    #logOverlay .logModal{
      height:100%;
      background:rgba(10,14,30,.98);
      border:1px solid rgba(255,255,255,.14);
      border-radius:20px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    #logOverlay .logHead{ padding:10px 12px; }
    #logOverlay .logBody{ padding:10px 12px; }
  </style>
</head>

<body>
<div id="app">

  <!-- LOBBY VIEW -->
  <section id="lobbyView" class="view">
    <div class="lobbyCard">
      <div class="lobbyTop">
        <div class="brand">
          <h1>üÉè Splash</h1>
          <div class="muted">Host a room or join your family‚Äôs room.</div>
        </div>
        <span class="pill" id="lobbyStatus">Not connected</span>
      </div>

      <div class="lobbyGrid">
        <div>
          <div class="muted" style="margin:0 0 6px;">Your name</div>
          <input id="mpNameLobby" placeholder="Aymen" />
        </div>
        <div>
          <div class="muted" style="margin:0 0 6px;">Room code</div>
          <input id="mpRoomLobby" placeholder="ROOM" style="text-transform:uppercase;" />
        </div>
      </div>

      <div class="lobbyActions">
        <button id="hostBtnLobby" class="primary">Host</button>
        <button id="joinBtnLobby" class="primary">Join</button>
      </div>

      <div class="lobbyFoot">
        <div class="roomHint">
          <div class="muted">Tip: share the room code with everyone.</div>
          <div class="pill">No observers ‚Ä¢ Online players only</div>
        </div>
        <div class="muted">In-game: tap a stack to select that rank. Drag a stack to the pile to play it.</div>
      </div>
    </div>
  </section>

  <!-- GAME VIEW -->
  <section id="gameView" class="view">
    <header>
      <div class="left">
        <div class="title">üÉè Splash</div>
        <span class="pill" id="roomPill">ROOM: ‚Äî</span>
        <span class="pill" id="turnInfo">Turn: ‚Äî</span>
      </div>

      <div class="right">
        <button id="newGame" class="primary">New Game</button>
        <button id="leaveBtn" class="danger">Leave</button>
      </div>
    </header>

    <main>
      <div class="grid">
        <section class="table">
          <div class="playersRow" id="playersRow"></div>

          <div class="pileBox">
            <div class="pileRow">
              <div style="display:flex; gap:8px; flex-wrap:wrap;">
                <span class="pill">Deck: <span id="deckCount">‚Äî</span></span>
                <span class="pill">Discard: <span id="discardCount">‚Äî</span></span>
                <span class="pill">Pile: <span id="pileCount">‚Äî</span></span>
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                <span class="muted">Top:</span>
                <span class="pill" id="topValue">‚Äî</span>
              </div>
            </div>
            <div class="pileVisual" id="pileVisual"></div>
            <div class="muted" style="margin-top:8px;">
              Tap a stack to select. Drag a stack onto the pile to play. (Or use buttons.)
            </div>
          </div>

          <div class="zoneTitle">
            <span>Your hand (grouped)</span>
            <span class="muted" id="turnHint"></span>
          </div>
          <div id="yourHand" class="handStacks"></div>

          <div class="zoneTitle">
            <span>Your table cards</span>
            <span class="muted">Play hand first</span>
          </div>
          <div id="yourTable" class="tableCards"></div>
        </section>

        <section class="panel">
          <div class="actionRow">
            <button id="playBtn" class="primary">Play Selected</button>
            <button id="pickupBtn" class="danger">Pick Up Pile</button>
          </div>

          <div class="actionRow">
            <button id="openLogBtn" class="primary">Log</button>
            <button id="clearSelBtn">Clear Selection</button>
          </div>

          <div class="pill" id="selPill">Selected: ‚Äî</div>

          <div class="logWrap">
            <div class="logHead">
              <div style="font-weight:900;">Game Log</div>
              <span class="muted">Latest on top</span>
            </div>
            <div id="log" class="logBody"></div>
          </div>
        </section>
      </div>
    </main>
  </section>

  <!-- Mobile log overlay -->
  <div id="logOverlay">
    <div class="logModal">
      <div class="logHead">
        <div style="font-weight:900;">Game Log</div>
        <button id="closeLogBtn" class="danger">Close</button>
      </div>
      <div id="logMobile" class="logBody"></div>
    </div>
  </div>

</div>

<script>
(() => {
  const WS_BASE = "wss://splash-multiplayer.azimaymen.workers.dev";
  const mpClientId = crypto.randomUUID();

  // Views
  const lobbyView = document.getElementById("lobbyView");
  const gameView  = document.getElementById("gameView");

  // Lobby inputs
  const mpNameLobby = document.getElementById("mpNameLobby");
  const mpRoomLobby = document.getElementById("mpRoomLobby");
  const lobbyStatus = document.getElementById("lobbyStatus");

  // Game header pills
  const roomPill = document.getElementById("roomPill");

  // Mobile log overlay
  const logOverlay = document.getElementById("logOverlay");
  const logMobile  = document.getElementById("logMobile");
  document.getElementById("openLogBtn").onclick = () => {
    syncMobileLog();
    logOverlay.style.display = "block";
  };
  document.getElementById("closeLogBtn").onclick = () => {
    logOverlay.style.display = "none";
  };
  logOverlay.addEventListener("click", (e) => {
    if (e.target === logOverlay) logOverlay.style.display = "none";
  });

  function showLobby(){
    gameView.style.display = "none";
    lobbyView.style.display = "flex";
  }
  function showGame(){
    lobbyView.style.display = "none";
    gameView.style.display = "flex";
  }

  // Multiplayer
  let mpWs = null;
  let mpRoom = null;
  let mpConnected = false;
  let mySeat = null;

  let reconnectAttempts = 0;
  let reconnectTimer = null;
  const MAX_RECONNECT_ATTEMPTS = 5;

  // Drag state for stacks
  const drag = { active:false, rank:null, ids:null, el:null, pid:null, moved:false, sx:0, sy:0 };

  // Game constants
  const SUITS = ["‚ô†", "‚ô•", "‚ô¶", "‚ô£"];
  const RANKS = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
  const RANK_ORDER = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
  const rankOrder = (r) => RANK_ORDER.indexOf(r);
  const isFace = (r) => r === "J" || r === "Q" || r === "K";

  const EMOJIS = ["ü¶ä", "üêº", "üêØ", "ü¶Å", "üê∏", "üêô", "ü¶â", "ü¶Ñ", "üê≤", "üê∂", "üê±", "üêµ"];

  const state = {
    players: [],
    deck: [],
    discard: [],
    pile: [],
    currentPlayer: 0,
    mustPlayAny: false
  };

  // selection now can contain many ids (stack selection)
  let selected = new Set(); // card ids

  // Helpers
  const el = (id) => document.getElementById(id);

  function setLobbyStatus(text, ok=false){
    lobbyStatus.textContent = text;
    lobbyStatus.style.borderColor = ok ? "rgba(126,231,135,.5)" : "rgba(255,255,255,.14)";
  }

  function saveConnectionInfo(room, name) {
    localStorage.setItem('splash_room', room);
    localStorage.setItem('splash_name', name);
  }
  function clearConnectionInfo() {
    localStorage.removeItem('splash_room');
    localStorage.removeItem('splash_name');
  }
  function loadConnectionInfo() {
    return {
      room: localStorage.getItem('splash_room'),
      name: localStorage.getItem('splash_name')
    };
  }

  function logLine(text, tone="") {
    const div = document.createElement("div");
    div.className = "logLine";
    const ts = new Date().toLocaleTimeString();
    div.innerHTML = `<span class="muted">[${ts}]</span> ${tone ? `<span class="${tone}">‚óè</span> ` : ""}${text}`;
    const log = el("log");
    log.prepend(div);
    syncMobileLog();
  }

  function syncMobileLog(){
    // mirror desktop log HTML into mobile
    logMobile.innerHTML = el("log").innerHTML;
  }

  function mpSendJoin() {
    if (!mpWs || mpWs.readyState !== WebSocket.OPEN) return;
    mpWs.send(JSON.stringify({
      type: "join",
      id: mpClientId,
      name: (mpNameLobby.value || "Player").trim()
    }));
  }

  function handleReconnect(room) {
    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      setLobbyStatus("Disconnected", false);
      logLine("Failed to reconnect after multiple attempts", "bad");
      return;
    }
    reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
    setLobbyStatus(`Reconnecting‚Ä¶ (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, false);
    reconnectTimer = setTimeout(() => {
      mpConnect(room);
    }, delay);
  }

  function mpConnect(room) {
    mpRoom = room.toUpperCase();
    roomPill.textContent = `ROOM: ${mpRoom}`;
    setLobbyStatus(`Connecting to ${mpRoom}‚Ä¶`, false);

    mpWs = new WebSocket(`${WS_BASE}?room=${mpRoom}`);
    saveConnectionInfo(mpRoom, (mpNameLobby.value || "").trim());

    mpWs.onopen = () => {
      mpConnected = true;
      reconnectAttempts = 0;
      setLobbyStatus(`Connected: ${mpRoom}`, true);
      mpSendJoin();
      showGame();
      logLine(`Connected to room ${mpRoom}`, "ok");
    };

    mpWs.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "players") {
        // server provides seat in worker players; our frontend still uses array index for seat
        mySeat = msg.players.findIndex(p => p.id === mpClientId);
        ensurePlayersFromServer(msg.players);
        render();
      }

      if (msg.type === "state") {
        const payload = msg.payload;
        applyRemoteState(payload.state);
      }

      if (msg.type === "reset") {
        logLine("Game was reset by host", "warn");
        resetLocalState();
        render();
      }

      if (msg.type === "pong") {}
    };

    mpWs.onclose = () => {
      mpConnected = false;
      setLobbyStatus("Disconnected", false);
      handleReconnect(room);
    };

    mpWs.onerror = () => {
      mpConnected = false;
      setLobbyStatus("Connection error", false);
    };

    setInterval(() => {
      if (mpWs && mpWs.readyState === WebSocket.OPEN) {
        mpWs.send(JSON.stringify({ type: "ping" }));
      }
    }, 30000);
  }

  // Server-authoritative: send ACTION instead of broadcast
  function mpSendAction(actionType, nextState) {
    if (!mpWs || mpWs.readyState !== WebSocket.OPEN) {
      logLine("Cannot sync - not connected", "warn");
      return;
    }
    mpWs.send(JSON.stringify({
      type: "action",
      action: { type: actionType, state: JSON.parse(JSON.stringify(nextState)) }
    }));
  }

  function mpLeave() {
    if (reconnectTimer) clearTimeout(reconnectTimer);
    if (mpWs) mpWs.close();
    mpConnected = false;
    mpRoom = null;
    mySeat = null;
    clearConnectionInfo();
    resetLocalState();
    selected.clear();
    render();
    showLobby();
    setLobbyStatus("Not connected", false);
    logLine("Left room", "warn");
  }

  // Lobby buttons
  document.getElementById("hostBtnLobby").onclick = () => {
    const name = (mpNameLobby.value || "").trim();
    if (!name) return alert("Enter your name first");
    const code = Math.random().toString(36).slice(2, 8).toUpperCase();
    mpRoomLobby.value = code;
    mpConnect(code);
    alert("Room code: " + code + "\nShare this with others to join!");
  };

  document.getElementById("joinBtnLobby").onclick = () => {
    const name = (mpNameLobby.value || "").trim();
    const code = (mpRoomLobby.value || "").trim();
    if (!name) return alert("Enter your name first");
    if (!code) return alert("Enter room code");
    mpConnect(code);
  };

  // Game buttons
  document.getElementById("leaveBtn").onclick = mpLeave;
  document.getElementById("clearSelBtn").onclick = () => {
    selected.clear();
    renderSelectionPill();
    render();
  };

  // Restore last room/name
  window.addEventListener("load", () => {
    const info = loadConnectionInfo();
    if (info.name) mpNameLobby.value = info.name;
    if (info.room) mpRoomLobby.value = info.room;
    showLobby();
    setLobbyStatus("Not connected", false);
    logLine("Welcome! Host or join a room.", "ok");
  });

  // ===== Game Logic =====
  function ensurePlayersFromServer(players) {
    while (state.players.length < players.length) {
      const idx = state.players.length;
      state.players.push({
        name: `Player ${idx + 1}`,
        emoji: EMOJIS[idx % EMOJIS.length],
        hand: [],
        tableUp: Array.from({ length: 4 }, () => null),
        tableDown: Array.from({ length: 4 }, () => null)
      });
    }
    players.forEach((p, idx) => {
      if (state.players[idx]) state.players[idx].name = p.name || `Player ${idx + 1}`;
    });
  }

  function applyRemoteState(remote) {
    if (!remote) return;
    state.players = remote.players;
    state.deck = remote.deck;
    state.discard = remote.discard;
    state.pile = remote.pile;
    state.currentPlayer = remote.currentPlayer;
    state.mustPlayAny = remote.mustPlayAny;
    selected.clear();
    render();
    renderSelectionPill();
  }

  function resetLocalState() {
    state.deck = [];
    state.discard = [];
    state.pile = [];
    state.currentPlayer = 0;
    state.mustPlayAny = false;
    // keep players array sizing
    state.players.forEach(p => {
      p.hand = [];
      p.tableUp = Array.from({ length: 4 }, () => null);
      p.tableDown = Array.from({ length: 4 }, () => null);
    });
  }

  function topRank() {
    return state.pile.length ? state.pile[state.pile.length - 1].rank : null;
  }

  function canPlayOnTop(rank) {
    if (state.mustPlayAny) return true;
    const top = topRank();
    if (!top) return true;
    if (rank === "10" || rank === "JOKER") return true;
    if (top === "10" || top === "JOKER") return false;
    if (isFace(rank) && !isFace(top)) return false;
    return rankOrder(rank) <= rankOrder(top);
  }

  function makeDeck() {
    const d = [];
    for (let k = 0; k < 2; k++) {
      for (const s of SUITS) {
        for (const r of RANKS) d.push({ id: crypto.randomUUID(), rank: r, suit: s });
      }
    }
    for (let j = 0; j < 4; j++) d.push({ id: crypto.randomUUID(), rank: "JOKER", suit: "‚òÖ" });
    for (let i = d.length - 1; i > 0; i--) {
      const k = Math.floor(Math.random() * (i + 1));
      [d[i], d[k]] = [d[k], d[i]];
    }
    return d;
  }

  function isMyTurn() {
    return mySeat !== null && mySeat === state.currentPlayer;
  }

  function newGame() {
    if (!mpConnected) { logLine("Must be connected to start", "bad"); return; }
    if (mySeat !== 0) { logLine("Only Host (Player 1) can start", "warn"); return; }

    state.deck = makeDeck();
    state.discard = [];
    state.pile = [];
    state.mustPlayAny = false;
    state.currentPlayer = 0;

    state.players.forEach(p => {
      p.hand = [];
      p.tableUp = Array.from({ length: 4 }, () => null);
      p.tableDown = Array.from({ length: 4 }, () => null);
    });

    for (let i = 0; i < 4; i++) state.players.forEach(p => p.tableDown[i] = state.deck.pop());
    for (let i = 0; i < 4; i++) state.players.forEach(p => p.tableUp[i] = state.deck.pop());
    for (let i = 0; i < 11; i++) state.players.forEach(p => p.hand.push(state.deck.pop()));

    const start = state.deck.pop();
    state.pile.push(start);
    if (start.rank === "10" || start.rank === "JOKER") {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
    }

    selected.clear();
    renderSelectionPill();
    logLine("Game started by host", "ok");
    mpSendAction("START", state);
    render();
  }

  document.getElementById("newGame").onclick = newGame;

  function playSelected() {
    if (!isMyTurn()) { logLine("Not your turn", "warn"); return; }
    if (mySeat === null) return;
    const me = state.players[mySeat];
    if (!me) return;
    if (!selected.size) return;

    const ids = Array.from(selected);
    const chosen = [];

    for (const id of ids) {
      const h = me.hand.find(c => c.id === id);
      if (h) chosen.push({ card: h, zone: "hand" });
      const upIdx = me.tableUp.findIndex(c => c && c.id === id);
      if (upIdx !== -1) chosen.push({ card: me.tableUp[upIdx], zone: "tableUp", idx: upIdx });
    }
    if (!chosen.length) return;

    const rank = chosen[0].card.rank;
    if (!chosen.every(x => x.card.rank === rank)) {
      logLine("Must play same rank", "bad");
      return;
    }
    if (!canPlayOnTop(rank)) {
      logLine("Illegal play - cannot play " + rank + " on " + topRank(), "bad");
      return;
    }

    chosen.forEach(x => {
      if (x.zone === "hand") me.hand = me.hand.filter(c => c.id !== x.card.id);
      if (x.zone === "tableUp") me.tableUp[x.idx] = null;
      state.pile.push(x.card);
    });
    selected.clear();
    renderSelectionPill();

    if (rank === "10" || rank === "JOKER") {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
      logLine("üéâ Clear! Play again", "ok");
      mpSendAction("UPDATE", state);
      render();
      return;
    }

    const cnt = state.pile.reduce((a, c) => a + (c.rank === rank ? 1 : 0), 0);
    if (cnt >= 3) {
      state.discard.push(...state.pile);
      state.pile = [];
      state.mustPlayAny = true;
      logLine("üéä Triple clear! Play again", "ok");
      mpSendAction("UPDATE", state);
      render();
      return;
    }

    state.mustPlayAny = false;
    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
    logLine("Played " + rank, "ok");
    mpSendAction("UPDATE", state);
    render();
  }

  document.getElementById("playBtn").onclick = playSelected;

  function pickup() {
    if (!isMyTurn()) { logLine("Not your turn", "warn"); return; }
    if (mySeat === null) return;
    const me = state.players[mySeat];
    me.hand.push(...state.pile);
    logLine("Picked up " + state.pile.length + " cards", "warn");
    state.pile = [];
    state.mustPlayAny = true;
    selected.clear();
    renderSelectionPill();
    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
    mpSendAction("UPDATE", state);
    render();
  }

  document.getElementById("pickupBtn").onclick = pickup;

  // ===== Grouping + selection =====
  function groupByRank(cards){
    const m = new Map();
    for(const c of cards){
      if(!m.has(c.rank)) m.set(c.rank, []);
      m.get(c.rank).push(c);
    }
    // stable sort by rank order: A..K + JOKER last
    const ranks = Array.from(m.keys()).sort((a,b) => {
      if (a === "JOKER" && b !== "JOKER") return 1;
      if (b === "JOKER" && a !== "JOKER") return -1;
      return RANK_ORDER.indexOf(a) - RANK_ORDER.indexOf(b);
    });
    return ranks.map(r => ({ rank:r, cards:m.get(r) }));
  }

  function renderSelectionPill(){
    const pill = el("selPill");
    if (!selected.size) { pill.textContent = "Selected: ‚Äî"; return; }
    // compute selected rank(s)
    if (mySeat === null || !state.players[mySeat]) { pill.textContent = `Selected: ${selected.size}`; return; }
    const me = state.players[mySeat];
    const anyId = selected.values().next().value;
    const anyCard = me.hand.find(x => x.id === anyId) || me.tableUp.find(x => x && x.id === anyId);
    pill.textContent = anyCard ? `Selected: ${anyCard.rank} √ó ${selected.size}` : `Selected: ${selected.size}`;
  }

  // ===== Drag to pile =====
  function isOverPile(x,y){
    const r = el("pileVisual").getBoundingClientRect();
    return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
  }
  function dragStart(rank, ids, stackEl, pid, x, y){
    drag.active = true;
    drag.rank = rank;
    drag.ids = ids;
    drag.el = stackEl;
    drag.pid = pid;
    drag.moved = false;
    drag.sx = x; drag.sy = y;
    el("pileVisual").classList.toggle("dragOver", false);
    stackEl.classList.add("dragging");
    stackEl.setPointerCapture(pid);
  }
  function dragMove(x,y){
    if(!drag.active) return;
    const dx = Math.abs(x - drag.sx);
    const dy = Math.abs(y - drag.sy);
    if(dx + dy > 6) drag.moved = true;
    el("pileVisual").classList.toggle("dragOver", isOverPile(x,y));
  }
  function dragEnd(x,y){
    if(!drag.active) return;
    el("pileVisual").classList.remove("dragOver");
    try{ drag.el.releasePointerCapture(drag.pid); }catch{}
    drag.el.classList.remove("dragging");

    if(drag.moved && isOverPile(x,y)){
      selected.clear();
      for (const id of drag.ids) selected.add(id);
      renderSelectionPill();
      playSelected();
    }

    drag.active=false; drag.rank=null; drag.ids=null; drag.el=null; drag.pid=null; drag.moved=false;
  }

  // ===== Render =====
  function render(){
    el("pileCount").textContent = String(state.pile.length);
    el("deckCount").textContent = String(state.deck.length);
    el("discardCount").textContent = String(state.discard.length);
    el("topValue").textContent = state.mustPlayAny ? "ANY" : (topRank() || "‚Äî");
    el("turnInfo").textContent = "Turn: " + (state.players[state.currentPlayer]?.name || "‚Äî");
    el("turnHint").textContent = isMyTurn() ? "üëâ Your turn!" : "Waiting‚Ä¶";

    const pr = el("playersRow");
    pr.innerHTML = "";
    state.players.forEach((p, idx) => {
      const d = document.createElement("div");
      d.className = `playerChip ${idx === state.currentPlayer ? "active" : ""}`;
      d.innerHTML = `
        <div class="avatar"><span class="emo">${p.emoji}</span><span class="seat">${idx+1}</span></div>
        <div style="min-width:0">
          <div style="font-weight:900; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${p.name}</div>
          <div class="muted" style="font-size:11px">Hand: ${p.hand.length} | Table: ${p.tableUp.filter(c => c).length}</div>
        </div>`;
      pr.appendChild(d);
    });

    // pile visual last 6
    const pv = el("pileVisual");
    pv.innerHTML = "";
    state.pile.slice(-6).forEach((c, i) => {
      const d = document.createElement("div");
      d.className = "c";
      d.style.position = "absolute";
      d.style.left = "50%";
      d.style.top = `${14 + i * 4}px`;
      d.style.transform = `translateX(-50%) rotate(${i * 4 - 8}deg)`;
      d.innerHTML = `<div class="corner top">${c.rank}<br>${c.suit}</div><div class="pip">${c.suit}</div><div class="corner bottom">${c.rank}<br>${c.suit}</div>`;
      pv.appendChild(d);
    });

    const handEl = el("yourHand");
    const tableEl = el("yourTable");
    handEl.innerHTML = "";
    tableEl.innerHTML = "";

    if (mySeat === null || !state.players[mySeat]) {
      handEl.innerHTML = '<div class="muted" style="padding:10px;text-align:center;">Join a room to see your cards</div>';
      renderSelectionPill();
      return;
    }

    const me = state.players[mySeat];

    // Render grouped hand stacks
    const groups = groupByRank(me.hand);

    groups.forEach(g => {
      const ids = g.cards.map(c => c.id);
      const top = g.cards[g.cards.length - 1];
      const legal = canPlayOnTop(g.rank);

      const stack = document.createElement("div");
      stack.className = "cardStack";

      // ghosts for count
      if (g.cards.length >= 2){
        const ghost1 = document.createElement("div");
        ghost1.className = "c stackGhost g1";
        ghost1.innerHTML = `<div class="corner top">${top.rank}<br>${top.suit}</div><div class="pip">${top.suit}</div><div class="corner bottom">${top.rank}<br>${top.suit}</div>`;
        stack.appendChild(ghost1);
      }
      if (g.cards.length >= 3){
        const ghost2 = document.createElement("div");
        ghost2.className = "c stackGhost g2";
        ghost2.innerHTML = `<div class="corner top">${top.rank}<br>${top.suit}</div><div class="pip">${top.suit}</div><div class="corner bottom">${top.rank}<br>${top.suit}</div>`;
        stack.appendChild(ghost2);
      }

      const card = document.createElement("div");
      card.className = "c selectable";
      if (!legal) card.classList.add("illegal");
      // if any id selected in this rank, show selected highlight on top card
      const selectedThisRank = ids.some(id => selected.has(id));
      if (selectedThisRank) card.classList.add("selected");
      card.innerHTML = `<div class="corner top">${top.rank}<br>${top.suit}</div><div class="pip">${top.suit}</div><div class="corner bottom">${top.rank}<br>${top.suit}</div>`;
      stack.appendChild(card);

      if (g.cards.length > 1){
        const badge = document.createElement("div");
        badge.className = "stackCount";
        badge.textContent = g.cards.length;
        stack.appendChild(badge);
      }

      // Tap: toggle selection of entire rank stack
      stack.onclick = () => {
        if (!isMyTurn()) { logLine("Wait for your turn", "warn"); return; }
        if (!legal) { logLine("Cannot play " + g.rank + " on " + topRank(), "bad"); return; }

        const anySelected = ids.some(id => selected.has(id));
        // Always keep selection to ONE rank at a time (consistent with game rules)
        selected.clear();
        if (!anySelected){
          ids.forEach(id => selected.add(id));
        }
        renderSelectionPill();
        render();
      };

      // Drag stack to pile
      stack.addEventListener("pointerdown", (e) => {
        if (!isMyTurn()) return;
        if (!legal) return;
        // keep selection in sync with drag
        selected.clear();
        ids.forEach(id => selected.add(id));
        renderSelectionPill();
        dragStart(g.rank, ids, stack, e.pointerId, e.clientX, e.clientY);
      });
      stack.addEventListener("pointermove", (e) => { if(!drag.active) return; dragMove(e.clientX, e.clientY); });
      stack.addEventListener("pointerup",   (e) => { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });
      stack.addEventListener("pointercancel",(e)=> { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });

      handEl.appendChild(stack);
    });

    // Render tableUp cards (individual) ‚Äì still 5 per row layout
    for (let i = 0; i < 4; i++){
      const up = me.tableUp[i];
      if (up){
        const d = document.createElement("div");
        d.className = "c selectable";
        const legal = canPlayOnTop(up.rank);
        if (!legal) d.classList.add("illegal");
        if (selected.has(up.id)) d.classList.add("selected");

        d.onclick = () => {
          if (!isMyTurn()) { logLine("Wait for your turn", "warn"); return; }
          if (me.hand.length > 0) { logLine("Must play hand cards first", "warn"); return; }
          if (!legal) { logLine("Cannot play " + up.rank + " on " + topRank(), "bad"); return; }

          // only one rank at a time
          selected.clear();
          selected.add(up.id);
          renderSelectionPill();
          render();
        };

        d.addEventListener("pointerdown", (e) => {
          if (!isMyTurn()) return;
          if (me.hand.length > 0) return;
          if (!legal) return;
          selected.clear();
          selected.add(up.id);
          renderSelectionPill();
          dragStart(up.rank, [up.id], d, e.pointerId, e.clientX, e.clientY);
        });
        d.addEventListener("pointermove", (e) => { if(!drag.active) return; dragMove(e.clientX, e.clientY); });
        d.addEventListener("pointerup",   (e) => { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });
        d.addEventListener("pointercancel",(e)=> { if(!drag.active) return; dragEnd(e.clientX, e.clientY); });

        d.innerHTML = `<div class="corner top">${up.rank}<br>${up.suit}</div><div class="pip">${up.suit}</div><div class="corner bottom">${up.rank}<br>${up.suit}</div>`;
        tableEl.appendChild(d);
      } else {
        const empty = document.createElement("div");
        empty.className = "c";
        empty.style.opacity = "0.18";
        empty.innerHTML = `<div class="pip">‚Äî</div>`;
        tableEl.appendChild(empty);
      }
    }

    // keep layout stable (grid expects 5 columns). add one empty filler
    const filler = document.createElement("div");
    filler.style.width = "var(--card-w)";
    filler.style.height = "var(--card-h)";
    filler.style.opacity = "0";
    tableEl.appendChild(filler);

    el("newGame").disabled = (mySeat !== 0 || !mpConnected);
    el("playBtn").disabled = (!isMyTurn() || !mpConnected || !selected.size);
    el("pickupBtn").disabled = (!isMyTurn() || !mpConnected);

    renderSelectionPill();
  }

})();
</script>
</body>
</html>
